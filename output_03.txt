Folder Structure
--------------------------------------------------
/
    temp.ps1
docs/
    AI_GUIDE.md
    Analyse av LEGO instruksjonsvisningssystem.md
    ARCHITECTURE.md
    CSS_GUIDELINES.md
    DATA_FORMAT.md
    IMPLEMENTATION.md
    README.md
    ROADMAP.md


File Contents
--------------------------------------------------


temp.ps1
File type: .ps1
Get-Content docs/README.md | Select-Object -Index 220..230


--------------------------------------------------
File End
--------------------------------------------------


docs\AI_GUIDE.md
File type: .md
# AI Guide - Start her f√∏r implementering

Dette dokumentet gir deg en rask oversikt over hvordan du skal jobbe med dette prosjektet. **Les dette f√∏rst**, deretter f√∏lg lenkene til de detaljerte dokumentene.

## üéØ Hva er dette prosjektet?

Et statisk nettsted for √• vise LEGO-byggeinstruksjoner som PNG-bilder. Bygget med ren HTML, CSS og JavaScript, uten dependencies.

**Hovedfunksjoner**:
- Prosjektgalleri med cover-bilder
- Hierarkisk navigasjon (prosjekter ‚Üí underprosjekter ‚Üí steg)
- Stegvis visning med pil-knapper og progresjonslinje
- Automatisk lagring av progresjon i localStorage
- Responsivt design (mobil, nettbrett, PC)

## üìã Hvor starter jeg?

### 1. **Les [ROADMAP.md](./ROADMAP.md) f√∏rst**
   - Dette er din implementasjonsplan
   - F√∏lg oppgavene i rekkef√∏lge (1.1 ‚Üí 1.2 ‚Üí 1.3 osv.)
   - **Viktig**: Test i nettleser ved alle steg markert med üåê

### 2. **For kode-implementering, se [IMPLEMENTATION.md](./IMPLEMENTATION.md)**
   - Funksjonssignaturer og eksempler
   - Kode-m√∏nstre og konvensjoner
   - Error handling og best practices

### 3. **For arkitektur og struktur, se [ARCHITECTURE.md](./ARCHITECTURE.md)**
   - Modulansvar og dataflyt
   - Routing og state management
   - Skalerbarhet og refaktoreringsstrategier

### 4. **For CSS og styling, se [CSS_GUIDELINES.md](./CSS_GUIDELINES.md)**
   - Design tokens og BEM-navngiving
   - Responsivt design (mobile-first)
   - Layout-komponenter og utility classes

### 5. **For dataformater, se [DATA_FORMAT.md](./DATA_FORMAT.md)**
   - Struktur p√• `meta.json` og `projects.json`
   - Validering og best practices
   - Eksempler p√• korrekt format

## ‚ö†Ô∏è Kritiske regler (les disse!)

### Klassnavn - M√Ö v√¶re konsistent
- **Bruke BEM-m√∏nster**: `.viewer__header`, `.project-tile__image`
- **IKKE bruke**: `.viewer-header`, `.project-name`
- Se [CSS_GUIDELINES.md](./CSS_GUIDELINES.md) for alle klassnavn

### Modulansvar - Ikke blande
- **main.js**: Koordinerer, gj√∏r IKKE DOM-rendering
- **view-*.js**: Bygger DOM, gj√∏r IKKE datahenting
- **data-loader.js**: Henter data, gj√∏r IKKE rendering
- Se [ARCHITECTURE.md](./ARCHITECTURE.md) for detaljer

### URL-bygging - Bruk alltid getImageUrl()
- **Riktig**: `img.src = getImageUrl(path, imageName)`
- **Feil**: `img.src = \`/projects/${path}/${imageName}\``
- Se [IMPLEMENTATION.md](./IMPLEMENTATION.md) for eksempler

### State management - Funksjoner, ikke objekter
- **Riktig**: `import { getState, updateState } from './state.js'`
- **Feil**: `state.getState()` eller `state.updateState()`
- Se [IMPLEMENTATION.md](./IMPLEMENTATION.md) for detaljer

## üó∫Ô∏è Dokumentoversikt

| Fil | Bruk n√•r du trenger... |
|-----|------------------------|
| **[ROADMAP.md](./ROADMAP.md)** | Implementasjonsplan og oppgaver |
| **[IMPLEMENTATION.md](./IMPLEMENTATION.md)** | Kodeeksempler og funksjonssignaturer |
| **[ARCHITECTURE.md](./ARCHITECTURE.md)** | Teknisk arkitektur og modulansvar |
| **[CSS_GUIDELINES.md](./CSS_GUIDELINES.md)** | Styling, design tokens, BEM-navngiving |
| **[DATA_FORMAT.md](./DATA_FORMAT.md)** | JSON-strukturer og dataformater |
| **[README.md](./README.md)** | Brukerinformasjon og prosjektoverview |

## üöÄ Arbeidsflyt

1. **Start med ROADMAP.md**
   - Velg neste oppgave (f.eks. 1.3.1)
   - Les "M√•l"-linjen for √• forst√• hva som skal gj√∏res

2. **Sjekk IMPLEMENTATION.md**
   - Finn relevant modul (f.eks. router.js)
   - Se p√• funksjonssignaturer og eksempler
   - F√∏lg kode-m√∏nstrene n√∏yaktig

3. **Implementer koden**
   - F√∏lg funksjonssignaturene som fasit
   - Bruk klassnavn fra CSS_GUIDELINES.md
   - Test i nettleser hvis oppgaven krever det

4. **Oppdater ROADMAP.md**
   - Marker oppgaven som fullf√∏rt: `[x]`
   - G√• videre til neste oppgave

## üîç Rask referanse

### Hvor finner jeg...?

**Hvordan sortere bilder?**
‚Üí [IMPLEMENTATION.md](./IMPLEMENTATION.md) - `extractStepNumber()` funksjon

**Hvordan bygge URL til bilder?**
‚Üí [IMPLEMENTATION.md](./IMPLEMENTATION.md) - `getImageUrl()` funksjon

**Hvordan beregne forelder-path?**
‚Üí [IMPLEMENTATION.md](./IMPLEMENTATION.md) - `getParentPath()` funksjon

**Hvilke CSS-klasser skal jeg bruke?**
‚Üí [CSS_GUIDELINES.md](./CSS_GUIDELINES.md) - Seksjon "BEM-navngiving"

**Hvordan strukturere meta.json?**
‚Üí [DATA_FORMAT.md](./DATA_FORMAT.md) - Seksjon "meta.json struktur"

**Hvordan skjule prosjekter/children?**
‚Üí [DATA_FORMAT.md](./DATA_FORMAT.md) - Seksjon "hidden felt" - Bruk `hidden: true` for √• skjule fra visning

**Hvordan h√•ndtere state?**
‚Üí [IMPLEMENTATION.md](./IMPLEMENTATION.md) - Seksjon "state.js"

**Hvordan h√•ndtere routing?**
‚Üí [IMPLEMENTATION.md](./IMPLEMENTATION.md) - Seksjon "router.js"

## ‚ö° Viktige p√•minnelser

- **Ikke finn opp egne varianter** - F√∏lg eksisterende m√∏nstre
- **Test i nettleser** - Alle steg med üåê m√• testes
- **Bruk konsistente klassnavn** - Sjekk CSS_GUIDELINES.md
- **Ikke blande modulansvar** - main.js koordinerer, views renderer
- **Bruk getImageUrl()** - Ikke hardkod URL-er
- **Oppdater ROADMAP.md** - Marker oppgaver som fullf√∏rt

## üÜò Hvis du er usikker

1. Sjekk [IMPLEMENTATION.md](./IMPLEMENTATION.md) for kodeeksempler
2. Sjekk [ARCHITECTURE.md](./ARCHITECTURE.md) for modulansvar
3. Sjekk [CSS_GUIDELINES.md](./CSS_GUIDELINES.md) for styling
4. Foresl√• 2-3 alternativer i en kommentar, ikke gjett

---

**Start med [ROADMAP.md](./ROADMAP.md) og f√∏lg oppgavene i rekkef√∏lge!**



--------------------------------------------------
File End
--------------------------------------------------


docs\Analyse av LEGO instruksjonsvisningssystem.md
File type: .md
# Analyse av LEGO instruksjonsvisningssystem

## Hovedform√•l og bruksflyt

L√∏sningen er et statisk nettsted som lar brukeren bla gjennom LEGO-byggeinstruksjoner presentert som bilder, p√• en m√•te som ligner en fysisk byggeinstruksjonsbok. Systemet organiserer instruksjonene i et hierarki av prosjekter (f.eks. ulike modeller) med mulige underprosjekter (deler av en modell), og stegvis bilder for hvert prosjekt. Hovedform√•let er √• gj√∏re det enkelt √• f√∏lge egne LEGO-instruksjoner trinn for trinn visuelt, uten behov for tekstbeskrivelser.

### Bruksscenario

N√•r nettsiden √•pnes, m√∏tes brukeren av et prosjektgalleri som viser oversikt over alle tilgjengelige prosjekter med et cover-bilde for hver modell. Hvert prosjekt representeres av et bilde (eventuelt et spesielt cover.png) og et prosjektnavn. Brukeren (f.eks. et barn) kan trykke p√• et prosjekt for √• √•pne det. Da vil systemet laste inn prosjektets bilder og vise f√∏rste instruksjonssteg i en bildevisning. Hvis prosjektet inneholder underprosjekter (f.eks. modul√¶re deler), vil et trykk p√• hovedprosjektet f√∏rst vise en underside med de tilh√∏rende underprosjektene i stedet for steg-bilder.

### Stegvis navigasjon

Instruksjonsvisningen (viewer) lar brukeren bla fram og tilbake gjennom instruksjonsbildene ved hjelp av tydelige pil-knapper til venstre og h√∏yre. En progresjonslinje nederst indikerer hvor langt man har kommet og kan klikkes eller dras for √• hoppe til et bestemt steg. Det vises ogs√• en steg-indikator (f.eks. "Steg X av N") som forteller hvilken byggeinstruksjon man ser p√• av totalt antall. Navigasjonen er utformet slik at man ikke trenger √• scrolle; bildet skaleres automatisk til skjermen for √• unng√• rulling. Dette gir en ren, fokusert opplevelse der brukeren kun blar side for side gjennom instruksjonene.

### Hierarkisk opp/ned-navigasjon

Brukeren kan n√•r som helst g√• opp ett niv√• i hierarkiet ved √• trykke en dedikert "Opp"-knapp. Denne knappen tar brukeren tilbake til forelder-niv√•et: fra et underprosjekt tilbake til hovedprosjektet, eller fra et hovedprosjekt tilbake til oversiktsgalleriet, avhengig av hvor man er. Slik kan man enkelt bytte mellom prosjekter og underprosjekter. Hele navigasjonsflyten er hash-basert, som betyr at URL-en oppdateres for hver navigasjon (f.eks. `#/p/prosjekt1?step=3` for prosjekt1 steg 4). Dette gj√∏r at man kan bookmarke eller dele en bestemt instruksjonsposisjon, og det sikrer at sideoppfriskning ikke mister posisjonen.

### Automatisk posisjonslagring

Systemet benytter localStorage i nettleseren til √• automatisk lagre hvor langt brukeren har kommet i hvert prosjekt. Dersom man lukker siden og kommer tilbake senere, vil applikasjonen huske siste bes√∏kte steg for hvert prosjekt og automatisk fortsette der man slapp (med mindre brukeren manuelt har valgt et annet steg eller startet p√• nytt). Dette er spesielt nyttig i et hjemmescenario ‚Äì man kan ta pauser og fortsette byggingen senere uten √• miste oversikten. Systemet leser inn lagret progresjon ved oppstart og bruker det dersom URL-en ikke spesifiserer et steg.

### Sammenfattende

Tilbyr systemet en komplett bruksflyt fra galleri til detaljvisning: Velg prosjekt ‚Üí bla steg-for-steg i bilder ‚Üí g√• opp for √• velge nytt prosjekt, med fortl√∏pende lagring av fremdrift. L√∏sningen fungerer p√• tvers av enheter (mobil, nettbrett, PC) med responsivt design, slik at b√•de barn og voksne kan bruke den p√• sin foretrukne enhet hjemme.

## Arkitektur og komponenter

Applikasjonen er bygget som en modul√¶r, komponentbasert single-page l√∏sning ved hjelp av ren HTML, CSS og JavaScript uten rammeverk eller eksterne avhengigheter. Arkitekturen f√∏lger et enkelt MVC-lignende prinsipp der datah√•ndtering, visning og kontroll er separert. Nedenfor er hovedkomponentene i systemet:

### main.js ‚Äì Hovedkontroller

Dette er inngangspunktet som koordinerer hele applikasjonen. Ved oppstart initialiserer den ruteren og applikasjonsstaten, og den lytter p√• ruteendringer. main.js sin oppgave er √• motta Route-objekter fra ruteren og bestemme hva som skal skje: for root-ruten hentes prosjektlisten og galleri-visningen rendres; for en prosjekt-rute hentes riktig meta-data og viewer-visningen rendres. main.js s√∏rger ogs√• for √• oppdatere applikasjonsstaten og URL-hashen ved navigasjon (f.eks. n√•r brukeren blar til neste steg). Et viktig prinsipp er at main.js eier all tilstand og URL-manipulasjon, mens grensesnittskomponentene er "dumme" visninger som bare bygger UI og utl√∏ser callbacks.

### router.js ‚Äì Rutingsmodul

Denne modulen h√•ndterer klient-side ruting basert p√• URL-hash (`window.location.hash`). Den lytter p√• hashchange-hendelser og parser hashstrengen til et Route-objekt som representerer enten root (galleri) eller et spesifikt prosjekt (med ev. steginformasjon). Eksempel: URL `#/p/project1/sub-a?step=3` parses til `{ type: "project", path: "project1/sub-a", stepIndex: 3 }`. Routeren validerer ogs√• at URL-en har gyldig format, og normaliserer den om n√∏dvendig. N√•r en gyldig rute er tolket, sender router.js dette til main.js sin route-handler. Hash-baseret ruting ble valgt fordi det fungerer s√∏ml√∏st p√• statiske sider uten behov for serverconfig, og gir unike bokmerker for hver visning.

### state.js ‚Äì Tilstandsh√•ndtering

Denne modulen holder styr p√• applikasjonens tilstand i minnet og synkroniserer progresjon med localStorage. AppState-objektet i minnet sporer n√•v√¶rende prosjekt (path), n√•v√¶rende stegindeks og prosjektmetadata som er lastet. state.js tilbyr funksjoner som `getState()`, `updateState(...)` for √• hente/oppdatere tilstanden p√• en kontrollert m√•te, i stedet for at komponentene manipulerer tilstand direkte. I tillegg h√•ndteres et separat progresjonskart (lagret i localStorage) som mapper hver prosjektpath til siste bes√∏kte steg. Funksjoner som `getLastStepFor(path)` og `setStepFor(path, index)` brukes for √• lagre/f√• tak i brukerens sist kjente posisjon per prosjekt. Dette designet gj√∏r at state-h√•ndteringen er sentralisert og konsistent, og sikrer at f.eks. lagring til localStorage skjer automatisk ved steg-endring.

### data-loader.js ‚Äì Datatilgang

Data-laget best√•r prim√¶rt av denne modulen, som er ansvarlig for √• hente inn JSON-data og bygge bilde-URLer. Den laster `projects.json` som inneholder listen over toppniv√• prosjekter til galleriet, samt individuelle `meta.json`-filer for hvert prosjekt eller underprosjekt. Meta-filene inneholder typisk metadata som prosjektets navn, liste over steg-bilder og eventuelle underprosjekter. data-loader.js tilbyr funksjoner som `loadProjects()` og `loadProjectMeta(path)` som returnerer disse dataene (asynkront). Den har ogs√• en viktig utility-funksjon `getImageUrl(path, imageName)` for √• bygge korrekt filbane til et gitt bilde. I stedet for √• hardkode filstier, skal utviklerne bruke `getImageUrl()` hver gang et bilde skal vises, for konsistens. Basen for alle bilde-URLer er `/projects/`-mappen p√• serveren. Modulen h√•ndterer ogs√• feil, f.eks. hvis en JSON-fil mangler, ved √• logge feilen og la applikasjonen h√•ndtere det grasi√∏st (f.eks. utelate manglende prosjekter fra listen).

### view-project-grid.js ‚Äì Prosjektgalleri-visning

Dette er en ren presentasjonsmodul som genererer DOM-innholdet for galleriet. Den tar inn data om prosjektene (fra projects.json) og bygger en grid med et kort/"tile" for hvert prosjekt. Hvert prosjekt-kort inneholder cover-bildet (enten cover.png hvis det finnes, ellers f√∏rste steg-bildet som fallback) og prosjektnavn. Kortene er klikkbare; ved klikk vil view-modulen kalle en callback-funksjon (sendt inn fra main.js) med den valgte prosjektstien. main.js mottar dette og oppdaterer hash-ruten for √• navigere videre. Slik holder view-modulen seg enkel: den presenterer data og gir brukerinteraksjon (klikk), men kjenner ikke logikken for navigasjon utover √• kalle callback. (Det nevnes ogs√• at galleriet kan vise en progresjonsindikator per prosjekt om implementert ‚Äì for eksempel en visuell mark√∏r om prosjektet er helt eller delvis gjennomf√∏rt. Dette var kanskje tenkt som en ekstra funksjon i grensesnittet.)

### view-viewer.js ‚Äì Instruksjonsvisning

Denne modulen bygger grensesnittet for selve bildevisningen av instruksjoner. N√•r `renderViewer()` kalles med aktuell state (inkl. prosjektets meta og n√•v√¶rende steg) og et sett av callback-funksjoner, oppretter modulen et DOM-element som viser det gjeldende instruksjonsbildet og navigasjonskontroller rundt det. UI-strukturen inkluderer typisk en topplinje (f.eks. prosjektets navn eller en hjem/opp-knapp), selve bildeomr√•det (som skalerer bildet) og en bunnmeny med navigasjonsknapper. Bunnmenyen inneholder venstre/h√∏yre pil for forrige/neste steg, en Opp-knapp for √• g√• tilbake ett niv√• i hierarkiet, en visuell progresjonslinje som fylles opp ettersom man blar fremover, og en stegindikator som viser f.eks. "Steg 3 av 10". Modulen h√•ndterer ogs√• spesialtilfeller: hvis steg-listen er tom (ingen bilder), vil den vise en melding (f.eks. "Instruksjoner kommer snart") og deaktivere pil-knapper. Alle interaksjoner (trykk p√• piler, opp-knapp, klikk p√• progresjonslinje) resulterer i at modulen anroper de tilh√∏rende callbackene (`onPrevStep`, `onNextStep`, `onStepChange`, `onGoUp` etc.) som main.js har sendt inn. Main.js oppdaterer s√• state og hash, hvorp√• routeren trigger en re-render med oppdatert state. Denne arkitekturen sikrer at view-viewer kun tar seg av det visuelle og ikke har logikk for hvordan navigasjon og state fungerer.

### Teknisk sammendrag

Teknisk er systemet sv√¶rt lettvekts: alt skjer i brukerens nettleser, uten behov for noen serverlogikk eller database. Designvalg som hash-basert routing, localStorage for progresjon og frav√¶r av rammeverk gj√∏r at l√∏sningen kan hostes hvor som helst (f.eks. GitHub Pages) og lastes raskt. Totalt sett gir den modul√¶re arkitekturen en tydelig separasjon av ansvar som er lett √• vedlikeholde og utvide. Nye funksjoner kan legges til ved √• introdusere nye moduler eller utvide eksisterende, uten √• blande logikk p√• tvers (f.eks. nye typer visninger skal lages som nye `view-*.js` filer iht. m√∏nsteret). Dette legger et robust grunnlag for videre utvikling.

## Dokumentasjonens nytte og mangler

Dokumentasjonen som er vedlagt er omfattende og tydelig strukturert for √• veilede en utvikler ‚Äì eller i dette tilfellet en AI ‚Äì gjennom implementeringen av systemet. Det mest positive er at dokumentene ser ut til √• v√¶re spesielt tilpasset AI-assistert utvikling, med eksplisitte retningslinjer og steg-for-steg instruksjoner:

### Struktur og veiledning

En egen AI Guide oppsummerer prosjektet og peker til relevante underdokumenter for detaljer. Utvikleren instrueres til √• starte med ROADMAP.md som inneholder en konkret implementasjonsplan med nummererte oppgaver i rekkef√∏lge. Hver oppgave har et m√•l og referanser til hvor i dokumentasjonen man finner n√∏dvendig info. For eksempel finnes det en oppgave 1.3.2 "Implementer view-project-grid.js" med klart m√•l ("rendre prosjektgalleri med cover-bilder og navn"). Slik brytes den totale utviklingen ned i sm√•, h√•ndterbare steg ‚Äì noe som er ideelt for en AI som jobber iterativt. Roadmap-en oppfordrer ogs√• til √• teste i nettleser underveis (merket med üåê), noe som sikrer at AI-en (eller den som overv√•ker) verifiserer funksjonalitet kontinuerlig.

### Omfattende referanse

Dokumentasjonen dekker alle viktige aspekter i egne filer: arkitektur, implementasjonsdetaljer, CSS-retningslinjer, dataformat og en brukerorientert README. Dette gj√∏r at n√•r AI-en st√∏ter p√• et spesifikt sp√∏rsm√•l ("Hvordan sortere bilder? Hvordan bygge bilde-URL?") finnes det peker til riktig seksjon i dokumentene. For eksempel beskriver IMPLEMENTATION.md n√∏yaktige funksjonssignaturer (som `getImageUrl(path, imageName)`) og hvordan de skal brukes. Dette forhindrer gjetting og misforst√•elser. I CSS_GUIDELINES.md defineres klassenavn og BEM-konvensjoner, slik at AI-en vet akkurat hva elementer skal hete i CSS/HTML. Det advares eksplisitt mot √• finne p√• egne varianter: "Bruk eksisterende m√∏nstre, ikke finn opp egne". Slike klare regler hjelper en AI til √• unng√• typiske feil som inkonsistent navngiving.

### Retningslinjer for AI

Spesielt nyttig er at IMPLEMENTATION.md har en seksjon "Hvordan denne guiden skal brukes (for AI)". Her presiseres det at AI-en skal f√∏lge spesifiserte funksjonssignaturer og typedefs som fasit, bruke samme modulansvarsfordeling som beskrevet, og ikke innf√∏re nye m√∏nstre uten √• oppdatere dokumentasjonen. Dette er gull verdt for AI-st√∏ttet arbeid, da det tvinger AI-en til √• holde seg innenfor rammene. Videre oppfordres det til √• heller sp√∏rre (f.eks. i en kommentar) hvis noe er usikkert, fremfor √• gjette seg frem. Slike r√•d bidrar til at AI-en tar en konservativ og kommuniserende tiln√¶rming.

### Styrker ved dokumentasjonen

Alt i alt gir dokumentasjonen et meget godt rammeverk for √• implementere systemet korrekt. Den er skrevet p√• et relativt enkelt spr√•k (norsk) med tydelige emoji-markeringer for viktige punkter (f.eks. ‚ö†Ô∏è for kritiske regler, üéØ for prosjektm√•l). Strukturen med et overordnet README for konseptuell oversikt og underliggende guider for hvert omr√•de, gj√∏r at man raskt finner fram. Eksempler p√• kodedesign (pseudokode og TypeScript-aktige typedefinisjoner) illustrerer hvordan ting er tenkt. Dessuten viser dokumentasjonen at forfatteren har tenkt gjennom skalerbarhet og vedlikehold, ved √• inkludere retningslinjer for n√•r og hvordan man b√∏r refaktorere hvis filer blir for store. Dette er nyttig for en AI som kanskje genererer mye kode ‚Äì det finnes rettesnorer for √• holde koden ryddig over tid.

### Manglende eller svake punkter

Til tross for alt det positive er det noen omr√•der dokumentasjonen ikke dekker utf√∏rlig, som kan v√¶re relevante for en AI-utvikler:

#### Brukeropplevelse og m√•lgruppe

Dokumentasjonen sier lite om designprinsipper for m√•lgruppen (barn 5‚Äì7 √•r). Fokus er p√• teknisk implementasjon. En AI som kun f√∏lger denne dokumentasjonen vil kunne bygge funksjonaliteten korrekt, men kan mangle veiledning p√• f.eks. hvordan UI b√∏r utformes for sm√• barn (st√∏rrelse p√• knapper, ikoner vs. tekst, fargevalg, osv.). Et eksempel er at prosjektgalleriet viser prosjektnavn i tekst, men det er ikke diskutert om barna faktisk kan lese disse. Her kunne dokumentasjonen med fordel nevnt retningslinjer for barnevennlig design (f.eks. "bruk enkle ikoner og minst mulig tekst"). Uten slik veiledning er det risiko for at AI-en lager et grensesnitt som teknisk fungerer, men som ikke er optimalt for de yngste brukerne.

#### Tilgjengelighet (Accessibility)

Relatert til ovennevnte nevnes ikke universell utforming eller tilrettelegging. For eksempel, alt-tekst p√• bilder (slik at synshemmede kan f√• bilder beskrevet) er ikke omtalt ‚Äì riktignok er dette en byggeinstruksjon med tunge bilder der alt-tekst muligens er mindre relevant, men det kunne v√¶rt ber√∏rt. Ogs√• kontrastkrav for farger, st√∏rrelse p√• trykkflater, osv., er ikke beskrevet. En AI uten slik info kunne oversett viktige detaljer (f.eks. lage for sm√• knapper eller lav kontrast).

#### Testing og feils√∏king

Dokumentasjonen oppfordrer til testing underveis, men det finnes ikke mye om enhetstester eller automatisert testing. En AI kunne hatt nytte av noen enkle testtilfeller beskrevet i dokumentene for √• verifisere logikken. For eksempel kunne ROADMAP.md inkludert kontrollsp√∏rsm√•l ("Etter steg 1.3.2, skal galleriet vise X prosjekter, ellers feil"). Slik eksplisitt forventningssjekk mangler, men er ikke kritisk.

#### Ytrelse og optimalisering

F√∏rstegangs versjonens dokumentasjon nevner planlagte forbedringer som caching og preloading, men gir ikke konkret veiledning til AI-en om hvordan optimalisere bildeflyt. En AI kunne implementert akkurat det som st√•r, men kanskje ikke tenke p√• √• f.eks. laste neste bilde i bakgrunnen. Enkelte slike optimaliseringer m√•tte AI-en i dag ha kommet opp med selv (eller f√•tt i oppdrag via roadmap senere).

### Oppsummert

Dokumentasjonen st√∏tter en vellykket teknisk implementering sv√¶rt godt, men den kunne v√¶rt supplert med mer om hvordan systemet skal oppleves av sluttbrukeren. Spesielt siden m√•lgruppen er barnehage-/sm√•skolebarn, ville et avsnitt om pedagogisk design og brukertesting med barn gitt AI-en bedre forutsetning for √• ta de riktige designvalgene. Likevel ‚Äì gitt dokumentets form√•l (implementasjonsguide) er det forst√•elig at disse aspektene ikke vies stor plass. En AI-utvikler med tilgang til generell kunnskap om UI/UX for barn b√∏r kombinere den kunnskapen med denne dokumentasjonen for beste resultat.

## Brukergrensesnitt for barn 5‚Äì7 √•r

Systemet er tiltenkt barn i alderen 5‚Äì7 √•r, som ofte ikke kan lese flytende enda og som har begrenset erfaring med komplekse brukergrensesnitt. Dermed m√• l√∏sningen utformes sv√¶rt intuitivt og visuelt, slik at barna kan bruke den helt p√• egen h√•nd hjemme som forutsatt. √Ö vurdere dagens UI og funksjonalitet opp mot denne m√•lgruppen avdekker noen potensielle barrierer for selvstendig bruk, samt muligheter for forbedringer.

### Aller f√∏rst

Barn i alderen 5‚Äì7 tenker i stor grad i konkrete bilder og symboler fremfor abstrakt tekst. If√∏lge utviklingspsykologi (Piaget) er yngre barn (rundt 3‚Äì5 √•r) i en fase der de forst√•r verden gjennom ikoner og fysiske handlinger langt mer enn skriftlig spr√•k. De er ogs√• mer komfortable med touch-skjermer enn mus/keyboard og har begrenset finmotorikk, noe som krever enkle, store interaktive elementer. Med dette i bakhodet, la oss se p√• grensesnittet:

### Barri√®rer for selvstendig bruk

Nedenfor er identifiserte problemomr√•der for sm√• barn, basert p√• dagens design, og forslag til hvordan disse kan utbedres:

| Potensiell barri√®re i UI | Forslag til forbedring |
|-------------------------|------------------------|
| **Tekstbaserte elementer**: Flere viktige UI-elementer krever leseferdighet. Eksempelvis vises prosjektnavnene som tekst under hvert cover-bilde i galleriet. I selve instruksjonsvisningen vises en tekst som "Steg X av N" for √• indikere posisjon. Ogs√• "Opp"-knappen kan v√¶re merket med ordet "Opp". Sm√• barn kan ikke lese disse ordene eller tolke tall-/tekstformatet "X av N" uten hjelp. | **Bruk ikoner og tall i stedet for tekst**: Bytt ut eller suppl√©r tekst med lettforst√•elige symboler. Prosjektene i galleriet kan representeres utelukkende ved cover-bildet ‚Äì navnet i tekst er ofte overfl√∏dig for et barn som uansett gjenkjenner bildet av modellen. For navigasjonsknapper, bruk intuitive ikoner: f.eks. et hus-ikon for hjem/oversikt (i stedet for ordet "Opp"), og piler for neste/forrige. Steg-indikatoren kan vises som tall alene (f.eks. "3/10") eller som en serie punkt/brikker som fylles opp, i stedet for "Steg 3 av 10" skrevet ut. Barn forst√•r enkle tall og mengder visuelt, selv om de ikke leser ordet "steg". Generelt b√∏r grensesnittet ha mer bilder, mindre tekst ‚Äì selv tekstetiketter under ikoner har begrenset nytte for en 5-√•ring. |
| **Sm√• eller tettpakkede knapper**: Dersom navigasjonsknapper eller klikkbare omr√•der er for sm√• eller for n√¶r hverandre, vil barn slite med √• treffe riktig. Dokumentasjonen beskriver f.eks. piler og en progresjonslinje i bunnfeltet, men spesifiserer ikke st√∏rrelse. En fem√•ring har mindre presisjonskontroll, og kan lett trykke feil hvis elementene er sm√• eller sitter tett. | **St√∏rre trykkflater og avstand**: Design knappene store, fargerike og tydelige. Forskning anbefaler ca 2 cm x 2 cm som minimum st√∏rrelse p√• touch-knapper for sm√• barn (mot ca 1x1 cm for voksne). Piler og andre kontrollknapper b√∏r derfor oppta en relativt stor del av skjermen (f.eks. kunne neste/forrige-pilene dekke hj√∏rnene eller sidene i viewer-vinduet). S√∏rg ogs√• for god luft mellom interaktive elementer, slik at det ikke er tvil om hvor man trykker. For eksempel kan venstre/h√∏yre pil plasseres i hvert sitt hj√∏rne nederst, mens Opp/hjem-knappen ligger i et hj√∏rne √∏verst ‚Äì da er de adskilt. Et grensesnitt som YouTube Kids illustrerer dette ved at knappene er mye st√∏rre og mer spredt enn i vanlig YouTube. |
| **Avanserte handlinger (drag/scroll)**: Progresjonslinjen kan dras og klikkes for √• hoppe til et steg. Denne funksjonen kan v√¶re for avansert for 5‚Äì6-√•ringer. Dragging krever motorikk og forst√•else av konseptet timeline. Barn kan ogs√• utilsiktet komme borti linjen og hoppe langt frem/bak uten √• forst√• hva som skjedde. | **Enklere navigasjonskontroll**: Behold progresjonslinjen som visuell indikator, men ikke legg opp til at barn m√• bruke den. Pilene er den prim√¶re navigasjonsmetoden og b√∏r presenteres som det enkleste valget. Man kan vurdere √• deaktivere dragging av progresjonslinjen i en evt. "barnemodus", eller legge inn en forsinkelse/bekreftelse (f.eks. at man m√• holde inne et ikon for √• aktivere hopp). Alternativt kan et trykk p√• progresjonslinjen hoppe p√• en mer forutsigbar m√•te (f.eks. ett segment frem/tilbake). Dersom hopping skal st√∏ttes, kunne man heller implementere en oversikt med sm√• forh√•ndsvisningsbilder (thumbnails) av stegene som barn kan peke p√• ‚Äì det er mer konkret enn √• dra en abstrakt slider. |
| **Manglende tilbakemelding**: Barn trenger umiddelbar respons n√•r de gj√∏r noe, ellers blir de forvirret eller ut√•lmodige. I dagens beskrivelse er det ikke nevnt noen tilbakemelding annet enn at bildet byttes n√•r man trykker pil. For et barn kan det v√¶re vanskelig √• vite om klikket ble registrert hvis det ikke skjer noe synlig eller h√∏rbart med en gang. | **Umiddelbar visuell/lyd respons**: Gi tydelig feedback ved brukerhandlinger. For eksempel, n√•r barnet trykker Neste-knappen, kan knappen blinke eller animere kort, og kanskje en liten "klikk"-lyd spilles av. Dette forsterker at "n√• bladde du frem et steg". P√• siste steg kan appen spille en liten fanfare eller vise konfetti p√• skjermen som bel√∏nning, slik at barnet forst√•r at modellen er ferdig bygget og f√•r en f√∏lelse av mestring. Slike direkte tilbakemeldinger holder p√• oppmerksomheten og gj√∏r opplevelsen mer engasjerende for de sm√•. |
| **Hierarkisk navigasjon og kontekst**: Konseptet med underprosjekter og det √• g√• "opp et niv√•" kan v√¶re abstrakt for barn. De kan bli usikre p√• hvor "Opp"-knappen tar dem (til forskjell fra f.eks. en Home-knapp). Hvis et prosjekt har flere niv√•er, forst√•r barnet at de bytter mellom deler? Det er mulig de trenger hjelp f√∏rste gang for √• skj√∏nne strukturen. | **Klarere navigasjonsikoner og muligens forenkling**: Bruk et hjem-hus ikon for √• indikere retur til hovedmenyen, da selv sm√• barn forst√•r symbolet for hjem. Om det er flere hierarki-niv√•er, kan en breadcrumb-lignende visning vurderes (sm√• ikoner som viser hvor man er ‚Äì f.eks. et lite hus for hovedmeny > et lite ikon av n√•v√¶rende prosjekt). Det kan ogs√• vurderes √• begrense hierarkidybden for √• unng√• forvirring; i praksis vil nok de fleste barna navigere hovedprosjekt ‚Üî underprosjekt, og sjelden mer enn ett niv√• ned. Ensikre ogs√• at knappene for √• navigere opp/ut er visuelt konsekvente og alltid p√• samme sted (f.eks. √∏verst til venstre), s√• barnet etter hvert skj√∏nner intuitivt hvor de trykker for √• komme tilbake. |

Som tabellen over oppsummerer, koker det ned til to hovedprinsipper: gj√∏re grensesnittet s√• enkelt og visuelt som mulig, og gi brukeren kontroll uten behov for √• lese. Ikoner, farger, lyd og store flater m√• erstatte tekst, sm√• knapper og avanserte gester. P√• denne m√•ten fjernes hinderne som kan kreve voksnes hjelp.

I tillegg kan det v√¶re lurt √• inkludere en kort intro for barna f√∏rste gang de bruker appen ‚Äì f.eks. at appen visuelt peker p√• "trykk her for neste bilde" med en animasjonspil, eller har en egen oppstartsillustrasjon som forteller (gjerne med en stemme eller figur) hvordan man bruker det. Slik in-app veiledning kan hjelpe barn til √• bli selvhjulpne raskere.

## Egnethet av struktur og skalerbarhet

Prosjektets struktur og teknologi-valg virker sv√¶rt godt tilpasset det tiltenkte bruksomr√•det, og det har ogs√• rom for skalerbarhet i flere dimensjoner.

### Passer for hjemmebruk

L√∏sningen er laget for √• kunne kj√∏res uten spesielle oppsett ‚Äì alt ligger som statiske filer som kan √•pnes i en nettleser. Dette betyr at en familie kan hoste det p√• en enkel m√•te (f.eks. via GitHub Pages eller ved √• √•pne en lokal server) uten √• m√•tte installere programvare eller ha en kraftig enhet. Frav√¶ret av eksterne biblioteker gj√∏r at siden laster raskt selv p√• eldre nettbrett, noe som er positivt n√•r barn ut√•lmodig vil i gang. At ingen ting trenger serverkommunikasjon under bruk (hele appen kj√∏rer i nettleseren) betyr ogs√• at man er robust mot nettverksproblemer ‚Äì en gang lastet, vil siden fortsette √• fungere selv om WiFi skulle dette ut. Dette er viktig i et hjemmemilj√∏ hvor man kanskje ikke alltid har stabil nett-tilgang.

### LocalStorage for progresjon

Valget om √• lagre fremdrift lokalt hos brukeren er enkelt men smart. For scenarioet (et barn som bygger litt hver dag, eller flere s√∏sken som bytter p√•), er det nyttig at appen husker hvor man var. LocalStorage gir dette uten noe som helst backend eller innlogging, og fungerer ogs√• i offline-situasjoner. En begrensning er at progresjon ikke synkroniseres p√• tvers av enheter ‚Äì hvis barnet bytter fra nettbrett til en PC, m√• de manuelt finne igjen steget. Men i praksis vil nok en bruker holde seg til √©n prim√¶renhet n√•r de bygger en modell. Lagringen er per browser-profil, s√• flere barn p√• samme enhet vil overskrive hverandres progresjon p√• et gitt prosjekt ‚Äì men de kan l√∏se det ved √• bruke forskjellige prosjekter eller ved √• ha forskjellige nettleserprofiler. For hjemmebruk er dette tilstrekkelig; behov for flerbrukerh√•ndtering anses ikke som kritisk.

### Hierarkisk data og skalering av innhold

Systemet st√∏tter at man kan legge til ganske komplekse prosjektstrukturer med underprosjekter og mange steg. Dataformatet (`projects.json` og `meta.json` per prosjekt) gj√∏r at selv om antallet prosjekter vokser, trenger ikke appen √• laste alt samtidig ‚Äì den laster prosjektlisten f√∏rst, og detaljer f√∏rst n√•r man g√•r inn i et prosjekt. Dette er effektivt. Om en familie skulle legge inn f.eks. 50 forskjellige byggeprosjekter, vil galleri-visningen vise 50 cover-bilder (som kan lastes med lazy-loading hvis n√∏dvendig). Klikker man et prosjekt med hundrevis av steg, vil `meta.json` for dette inneholde en liste over bilde-filer, men selve bildene kan lastes ett og ett eller i mindre batcher. Dette betyr at skaleringen i antall prosjekter og steg stort sett h√•ndteres greit med dagens arkitektur. Et potensielt ytelseproblem kan v√¶re hvis et enkelt prosjekt inneholder meget mange steg (f.eks. 500+ bilder), da kan det ta litt tid √• laste `meta.json` og eventuelt oppdatere UI med progresjonslinje etc. Men siden bildene ikke legges inn i DOM samtidig ‚Äì bare ett vises av gangen ‚Äì er minnefotavtrykket lavt. Ytelsesforbedringer som caching og preloading er allerede tenkt p√• som "Planlagte funksjoner" i dokumentasjonen, noe som vitner om at arkitekturen er ment √• kunne utvides for √• takle mer innhold og bruk.

### Kodearkitektur og vedlikehold

Strukturmessig er koden delt i moduler med klart avgrenset ansvar, noe som er veldig bra for skalerbarhet i form av √• legge til nye funksjoner. For eksempel, om man senere vil legge til en ny visning (si en "s√∏kefunksjon" eller en "delingsside"), kan dette sannsynligvis gj√∏res ved √• lage nye view- og datamoduler uten √• forstyrre eksisterende logikk. At routeren er hash-basert gir ogs√• mulighet for nye rutetyper enkelt (man kunne f.eks. definere `/#/search?q=hus` for √• s√∏ke etter prosjekter med "hus"). Mangelen p√• rammeverk betyr at utviklere har full kontroll, men det krever ogs√• disiplin n√•r appen vokser. Heldigvis s√∏rger dokumentasjonens retningslinjer for at man holder seg til et konsistent m√∏nster, og den diskuterer til og med n√•r det er p√• tide √• splitte opp store filer. Dette lover godt for vedlikehold: man har et kompass √• navigere etter dersom kompleksiteten √∏ker.

### Skalerbarhet ‚Äì oppsummering

For det tiltenkte bruksscenariet (lek og bygging hjemme) er l√∏sningen per i dag velbalansert. Den bruker enkle teknologier som er lette √• skalere opp i omfang (flere prosjekter, flere brukere) uten kapasitetsproblemer, s√• lenge det dreier seg om et tosifret antall prosjekter og noen hundre bilder totalt. Skulle prosjektet vokse utover dette ‚Äì f.eks. en hel nettside der mange brukere laster ned og legger inn sine modeller ‚Äì ville man kanskje √∏nske seg et mer robust backend-system for deling. Men det er utenfor scope; her er poenget at for personlig/familiebruk skalerer systemet fint. En mulig utfordring ved stor skala kunne v√¶rt organisering av sv√¶rt mange prosjekter (da ville man trenge kategorier, s√∏k, etc.), men pr. n√• er hierarkiet fleksibelt nok til √• organisere prosjekter i mapper. Takket v√¶re JSON-formatet kan man strukturere ting logisk, og oppdatere filer manuelt for √• legge til nye innhold, noe en litt datakyndig voksen kan gj√∏re.

Kort sagt: Arkitekturen passer form√•let og gir en god base for b√•de √• bruke systemet hjemme og bygge videre p√• det over tid.

## Forslag til forbedringer

Basert p√• analysen over og tanke p√• beste praksis, kommer her noen konkrete forslag til forbedringer eller tilleggsfunksjonalitet. Disse er delt i to kategorier: tekniske forbedringer (koden og systemet under panseret) og forbedringer i brukeropplevelsen (UI/UX), selv om det er noe overlapp mellom dem.

### Tekniske forbedringer

#### Forh√•ndslasting av bilder

Implementer lazy loading og prefetching for instruksjonsbilder. N√•r brukeren er p√• steg n, kan appen i bakgrunnen laste steg n+1 (og kanskje n+2) proaktivt. Da oppleves bladingen glattere, uten lastetid per bilde. Tilsvarende kan f√∏rste bilde lastes med √©n gang et prosjekt √•pnes, mens resten av bildene lastes sekvensielt eller i grupper. Dette er foresl√•tt som del av planlagte funksjoner (preloading og caching) og b√∏r prioriteres for bedre ytelse.

#### Indikator ved lasting

Dersom et bilde tar mer enn et √∏yeblikk √• laste (f.eks. ved treg nettforbindelse eller stort bilde), b√∏r UI vise en enkel loading-spinner eller en "Laster..."-ikon. Siden barn er ut√•lmodige, kan en morsom animasjon (for eksempel en LEGO-kloss som spretter) gj√∏re ventetiden mer tolerabel. Dokumentasjonen nevner loading-indikatorer som en planlagt funksjon, noe vi st√∏tter √• implementere.

#### Progressiv Web App (PWA)

Gj√∏r nettstedet om til en PWA slik at det kan installeres som en app p√• nettbrett/mobil og fungere helt offline. Dette krever et manifest og en service worker for caching. Fordelen er at barna (eller foreldre) kan √•pne instruksjonene via en app-ikon, og alle n√∏dvendige filer (HTML, CSS, JS og bilder) kan lagres lokalt for rask gjentatt bruk. Et slikt offline-cache vil komplementere dagens design og er spesielt nyttig hvis man tar med nettbrettet til et sted uten internett. Teknisk er det gjennomf√∏rbart siden alt innhold er statisk.

#### St√∏tte for QR-koder og deling

Allerede planlagt er funksjonalitet for √• generere QR-koder for √• dele et spesifikt steg. Dette vil v√¶re en morsom og nyttig funksjon ‚Äì f.eks. kan man printe ut en QR-kode og klistre den p√• en fysisk modell, slik at andre kan skanne den og f√• opp akkurat det steget i byggingen. Implementasjon av dette vil kreve √• bruke en QR-bibliotek (client-side JS) som genererer en kode basert p√• current URL (hash). Teknisk sett rett frem, og et pluss for brukere. S√∏rg for at UI for dette er enkelt (kanskje et lite QR-ikon som voksen kan trykke p√•; man kan vurdere √• skjule det i en "voksen-modus" s√• ikke barnet trykker det ved et uhell).

#### Forbedret feilhandtering og diagnostikk

Inkluder brukerfeedback hvis data mangler. Per i dag h√•ndteres manglende filer ved `console.error` i data-loader. For en sluttbruker (forelder) som har lagt til egne bilder, kunne applikasjonen gi et vennlig hint i UI, f.eks. "Oi, fant ikke filen X.png ‚Äì sjekk navn og fors√∏k igjen." Dette krever litt UI arbeid, men kan spare frustrasjon n√•r man utvider med egne prosjekter.

#### Skaleringsfunksjon for bilder

En mulig teknisk/UX hybrid-forbedring: Legg til mulighet for √• zoome inn p√• et bilde. Selv om l√∏sningen unng√•r scrolling ved √• tilpasse bildet skjermen (contain), kan detaljer i LEGO-instruksjoner noen ganger v√¶re sm√•. √Ö la brukeren pinch-zoome (p√• touch) eller klikke for √• forst√∏rre bildet i en modal kan hjelpe ved kompliserte steg. Teknisk sett kan dette gj√∏res ved √• aktivere CSS transform p√• bildet ved gesture events, eller bare tilby en "Fullskjerm"-knapp som viser bildet i h√∏yere oppl√∏sning. Viktig er √• begrense det slik at barnet ikke kommer ut av fatning ‚Äì f.eks. en tilbakestill zoom knapp/gesture b√∏r finnes.

#### Tilpasning for flere spr√•k

Selv om appen prim√¶rt er ikonbasert for barna, finnes det noen tekstelementer (f.eks. "Steg X av N", eller eventuelle feilmeldinger). For √• gj√∏re det enklere for foreldre som ikke leser norsk, kan man abstrahere tekst til en spr√•kfil. Da kan man enkelt oversette UI-ord (f.eks. "Opp", "Steg", "av") til engelsk, tysk etc. Dette vil √∏ke anvendeligheten internasjonalt. Tekniske grep for dette er enkle (en JSON for spr√•kstrenger og en funksjon `t(key)` for √• hente teksten). Alternativt kan man fjerne behovet for oversettelse ved √• som sagt bruke symboler i stedet for ord.

### Forbedringer i brukeropplevelsen

#### Enklere startside for barn

Gj√∏r forsiden (prosjektgalleriet) s√• enkel som mulig √• forst√•. For eksempel, fremfor √• vise en kompleks layout, kan man presentere hvert prosjekt som et stort, fargerikt ikon/bilde. Kanskje legge til en morsom tittel over, som "Velg hva du vil bygge:" med store bokstaver og evt. en LEGO-mann-figur ved siden (dog tekst er mest for voksne ‚Äì en talemelding eller animasjon av en figur som peker p√• f√∏rste prosjektikon kunne fungere). Poenget er √• umiddelbart signalisere hva man skal gj√∏re: trykke p√• et bilde for √• starte.

#### Visuell fremdrift i galleri

I galleriet kunne hvert prosjektikon indikere fremdrift p√• en barnevennlig m√•te, slik at barnet ser hvilke modeller de har bygget ferdig eller hvor de har noe igjen. F.eks. ved √• legge en halvtransparent overlay p√• cover-bildet: en gr√∏nn checkmark for ferdig bygget, eller en liten progress-bar under bildet. Dette kan motivere barnet ("den har jeg bygget, den har jeg igjen"). Men utformingen m√• v√¶re intuitiv ‚Äì kanskje en fylt sirkel eller stjerne som g√•r fra tom til full farge basert p√• % fullf√∏rt. (Man m√• vurdere om barn forst√•r prosent; en helfarget stjerne kan bety "ferdig".)

#### Tilpasset bel√∏nning ved fullf√∏ring

N√•r et prosjekt er 100% fullf√∏rt (alle steg gjennomg√•tt), kan appen gj√∏re noe spesielt for barnet. For eksempel: en skjerm som sier "Gratulerer!" med konfetti og en stor gullmedalje-ikon, eller l√•se opp et digitalt klistremerke/badge i en liten samling. Dette gir mestringsf√∏lelse. Slike bel√∏nninger b√∏r v√¶re enkle og uten tekst, f.eks. en animert figur som danser eller en fanfare. Dette er st√∏ttet av UX-forskning som anbefaler √• feire barns prestasjoner for √• holde motivasjonen oppe.

#### Lydst√∏tte og narrativ

√Ö integrere lyd kan betydelig √∏ke et barns forst√•else og engasjement. Dette kan gj√∏res p√• flere m√•ter:

- **Lydinstruksjoner**: Ha en knapp (med et h√∏yttaler-ikon) som n√•r den trykkes, leser opp instruksen eller navnet p√• modellen. For eksempel kunne en stemme si "Bygg huset v√•rt ‚Äì steg 3". Dette krever at prosjektnavn og tall kan mapper til tale. Alternativt kan man kun lese tall ("tre av ti") kombinert med en enkel frase ("neste steg"). Selv om LEGO-instruksjoner normalt er spr√•kuavhengige, kan slike hint v√¶re fine.

- **Feedback-lyder**: Som nevnt i barrierene: korte, ikke-skremmende lydeffekter ved interaksjon (klikk, blad, tilbake). S√∏rg for at lydene er milde og gjerne valgfrie (kanskje et lyd-av/p√• toggle et sted, da noen foreldre foretrekker stille apper).

- **Bakgrunnsmusikk**: Man kan vurdere rolig bakgrunnsmusikk eller lydlandskap for √• holde barnets interesse. Men dette m√• is√•fall kunne sl√•s av og ikke v√¶re forstyrrende for konsentrasjonen ved bygging.

#### Gesture-baserte kontroller

Barn som bruker nettbrett er ofte vant til gestures (f.eks. swipe). For √• gj√∏re appen mer naturlig kan man implementere at swipe venstre/h√∏yre p√• instruksjonsbildet ogs√• blar til neste/forrige steg (i tillegg til pilknappene). Mange barn pr√∏ver intuitivt √• sveipe bilder, siden det ligner bildegalleri-adferd. Dette vil gj√∏re navigeringen enda mer direkte for dem. Man m√• likevel beholde pilene synlige som affordance, men la begge metoder fungere.

#### Visuell design med tema

Siden dette handler om LEGO, kunne grensesnittet gjenspeile LEGO-tema mer. For eksempel bruke klassiske LEGO-farger (r√∏d, bl√•, gul, gr√∏nn) i bakgrunner og knapper, og kanskje en stilisert LEGO-knopp eller figur som dekor. En id√© er √• ha en maskot (en minifigur) som viser seg ved viktige hendelser (f.eks. vinker n√•r du √•pner en ny instruksjon, eller gir tommel opp ved fullf√∏ring). Dette skaper en leken atmosf√¶re som passer m√•lgruppen. Det er viktig √• bruke sterke kontrastfarger og tydelige former, fordi barn tiltrekkes av dette og det hjelper dem √• fokusere p√• interaktive elementer.

#### Forenkle hierarki i UI

Hvis underprosjekter er et avansert konsept, kan man i stedet presentere dem litt annerledes. For eksempel, n√•r man √•pner et prosjekt med underprosjekter, kunne appen forklare visuelt: vise hovedprosjektet som et stort bilde og underprosjektene som mindre ikoner under, nesten som en meny med bilder. Barnet trykker da direkte p√• underdelene. Dette i stedet for at de skal navigere opp/ned flere niv√•er ‚Äì alt vises p√• en side som valg. Dette er en design-endring som kan testes, men tanken er √• flattrykke hierarkiet litt mer i grensesnittet, selv om strukturen i data er hierarkisk.

### Oppsummert

Alle UX-forbedringer b√∏r ha stikkordene: enkelt, stort, fargerikt, direkte og morsomt. Ved √• iterere p√• designet med faktiske barn (brukertesting) kan man avdekke hva de forst√•r og ikke. Kanskje man finner ut at et visst ikon ikke ga mening og bytter det ut med et mer bokstavelig symbol (f.eks. bytte ut et abstrakt pil opp-symbol med et hus-symbol for "til hovedmeny", siden barn skj√∏nner huset bedre). Sm√• justeringer der barnas perspektiv tas med vil gj√∏re systemet enda mer selvforklarende.

## Forslag til visuell design for m√•lgruppen

Til slutt presenteres et helhetlig forslag til visuell utforming som vil appellere til barn i 5‚Äì7 √•rs alderen, samtidig som det ivaretar brukervennlighet p√• touch-skjermer:

### Farger og tema

Bruk en lys og glad fargepalett med h√∏y kontrast. For eksempel kan bakgrunn v√¶re lys bl√• eller lys gr√• (n√∏ytral, for ikke √• stjele fokus fra instruksjonsbildene), mens interaktive elementer som knapper er i prim√¶rfargene r√∏d, gul, gr√∏nn eller bl√• ‚Äì disse fargene er b√•de i LEGO-klosser og intuitive for barn. Unng√• m√∏rke eller grumsete farger. Store flater kan ha en subtil m√∏nster av LEGO-knopper eller klosser for √• gi identitet, men ikke s√• mye at det distraherer.

### Ikoner og symboler

Bytt ut tekstlige labels helt med ikoner som barn kjenner igjen. Hjem-knapp: et hus-ikon. Tilbake/opp: en pil som peker mot venstre (universelt "tilbake"-symbol) plassert √∏verst p√• siden. Neste/forrige steg: store, fyldige piler (‚ñ∂Ô∏è‚óÄÔ∏è) p√• hver side av skjermen. For ekstra tydelighet kan pilene v√¶re inne i sirkler eller firkanter i kontrastfarge. Progresjon: vis som en horisontal rekke med sm√• ikoner (f.eks. sm√• firkanter eller stjerner) nederst som fylles n√•r man blar ‚Äì eller en enkel progress-bar med sterk farge. Unng√• kompliserte symboler som ikke gir mening for barn (f.eks. en tannhjul ‚öôÔ∏è for innstillinger gir lite mening ‚Äì om innstillinger finnes, bruk en enkel figur eller tekst som voksne f√•r ta seg av i et skjult menyhj√∏rne). N√•r man vurderer ikoner, test dem: et ikon som gir mening for en voksen (f.eks. et kompass for "utforsk") kan v√¶re uforst√•elig for en 5-√•ring, s√• heller bruk noe mer konkret (f.eks. piler i forskjellige retninger kan bedre signalisere "utforsk" enn et kompass). Alle ikoner b√∏r ha tilstrekkelig st√∏rrelse og gjerne en tydelig ramme eller bakgrunnsfarge slik at de skiller seg ut fra bildene bak.

### Typografi (minimalt)

Ideelt sett skal appen kunne brukes uten √• lese, men enkelte steder kan tekst for voksne dukke opp (f.eks. tittel p√• siden, eller feilmeldinger). Bruk da en stor, lettlest font som ogs√• ser vennlig ut ‚Äì f.eks. en rund sans-serif font. Unng√• lange setninger, hold det til maks et par ord. For barna kan man bruke tall (stegnummer) i stor fontst√∏rrelse hvis n√∏dvendig, og kanskje kombinere tallet med en liten ikon (f.eks. et lite bilde av klosser) for √• symbolisere "steg". Tekst kontrast skal f√∏lge retningslinjer (m√∏rk tekst p√• lys bakgrunn eller omvendt) for √• v√¶re tydelig.

### Layout og interaksjonsflater

Designen m√• v√¶re touch-vennlig. Dette betyr store knapper (minst 7-10mm i faktisk st√∏rrelse p√• enhet, ca 2cm p√• skjermen for √• kompensere for sm√• fingre) med god avstand. Vi foresl√•r at navigasjonsknappene (pilene) er halvtransparente over bildets venstre/h√∏yre side, hver dekket kanskje 15-20% av bredden ‚Äì da kan barnet bare trykke et sted p√• venstre halvdel for tilbake eller h√∏yre halvdel for neste, noe som er enklere enn √• m√•tte treffe en liten pil. (Dette kan kombineres med synlige pil-ikoner som indikasjon.) Opp/hjem-knappen kan ligge trygt oppe i venstre hj√∏rne ‚Äì typisk er det et omr√•de barn av og til kommer borti, men det kan gj√∏res litt mindre i√∏ynefallende enn pilene s√• de ikke klikker det ved et uhell hele tiden. Videre b√∏r elementer som progresjonslinjen v√¶re h√∏yere enn vanlig (slik at det er lett √• trykke p√• den dersom man skal det) og gjerne reagere ogs√• p√• tap (ikke bare drag).

### Illustrasjoner og figurer

Barn responderer positivt p√• kjente figurer og sm√• overraskelser. Man kan inkludere en LEGO minifigur maskot som guider brukeren. For eksempel en tegneseriefigur (fra LEGO-universet, eller en generisk byggmester-karakter) som dukker opp p√• forsiden og kanskje sier hei. Denne figuren kan ogs√• vises i en hjelpseksjon, eller holde en pekeboble som viser hva du skal gj√∏re ("Trykk p√• et bilde for √• starte"). Siden vi √∏nsker minimal tekst, kan figuren i stedet formidle med gest eller animerte bevegelser ‚Äì f.eks. peke mot galleriikonene. Slike sm√• innslag gj√∏r appen mer personlig og morsom uten √• kreve lesing.

### Animasjoner

Bruk enkle animasjoner for √• skape en f√∏lelse av liv. Eksempler: N√•r man blar til neste steg, la bildet fade ut/in eller gli til side som om man blar en side. Dette er intuitive overganger som hjelper barnet √• forst√• at vi gikk videre, ikke at bildet bare magisk endret seg. Navigasjonsknapper kan pulse (lett forst√∏rre/minske) for √• dra oppmerksomhet n√•r de f√∏rste gang vises, slik at barnet legger merke til dem. Interaktive ikoner kan ha en hover/trykk-effekt (for touch kan det v√¶re at de lyser opp kort n√•r trykket registreres). Pass p√• at animasjonene er korte og ikke hindrer rask bruk ‚Äì de skal st√∏tte forst√•elsen, ikke skape venting.

### Lyd og haptikk

Som delvis nevnt tidligere, integrer lyd feedback. For visuell design betyr dette at man m√• ha ikoner for lyd av/p√• et sted hvis det er aktuelt (kanskje i et hj√∏rne for foreldre). Men mer sentralt: design med tanke p√• at det kommer lyd. F.eks. kan en knappikon av en h√∏yttaler plasseres ved siden av step-indikatoren eller som en del av toppfeltet, slik at barnet vet at her kan de f√• noe opplest eller en hint (om man legger til fortellerstemme). N√•r det gjelder haptikk: p√• nettbrett kan trykk trigge en liten vibrasjon som bekreftelse ‚Äì dette styres av OS, men appen kan be om det p√• mobile enheter ved user gesture. En liten vibrasjon sammen med en klikklyd gir veldig tydelig signal p√• en handling. Designmessig trenger man ikke vise noe for haptikk, men man m√• teste at knappene ikke er for sm√• til at OS-et registrerer det som en knapp for haptisk feedback (derfor store flater).

### Tilpasset barns motorikk

Unng√• krav om presisjon. For eksempel, istedenfor en liten scrollbar eller tiny close-knapp, bruk sveip for √• lukke modaler eller store "X"-ikoner. Hvis det er noen skjerm med flere valg (for eksempel en dialog), s√∏rg for at de er store og tydelige ‚Äì eventuelt unng√• modale dialoger helt for barn, og heller gj√∏re handlinger reversible uten bekreftelse (f.eks. i stedet for "Er du sikker p√• at du vil til hovedmenyen?" kan man heller la dem g√• til hovedmeny og s√• kunne g√• tilbake igjen hvis det var feil, siden confirm-dialog med tekst uansett ikke leses av barnet).

### Oppsummering

Ved √• f√∏lge disse prinsippene vil det resulterende designet v√¶re fargerikt, enkelt og engasjerende ‚Äì akkurat det barn i 5‚Äì7-√•rsalderen trenger. Figurativt sett: Tenk deg at appen ser ut som en side fra en barnebok eller en LEGO Juniors instruksjonsbok, heller enn en teknisk applikasjon. Store ikoner, glade farger, og en tydelig vei for hva man skal gj√∏re videre til enhver tid. Da vil selv en fem√•ring kunne sette seg ned med nettbrettet og bygge LEGO-modellen sin ved hjelp av denne appen, helt uten hjelp, mens foreldrene kan f√∏lge med fra sidelinja og h√∏re barnets begeistring over √• selv klare √• f√∏lge instruksjonene.



--------------------------------------------------
File End
--------------------------------------------------


docs\ARCHITECTURE.md
File type: .md
# Arkitektur

Dette dokumentet beskriver den tekniske arkitekturen til LEGO Instruksjonsvisning-prosjektet.

## TL;DR - Mental modell

Applikasjonen best√•r grovt av:
- **Router** som tolker URL-en
- **Data-lag** som henter JSON og lagrer progresjon
- **Views** som bygger DOM-en for galleri og viewer
- **main.js** som kobler alt sammen

For brukerinformasjon og hvordan du legger til prosjekter, se [README.md](./README.md). Dette dokumentet fokuserer p√• den tekniske implementasjonen.

## Arkitekturoversikt

Prosjektet er bygget som en modul√¶r, komponentbasert applikasjon med ren JavaScript. Arkitekturen f√∏lger en enkel MVC-lignende struktur hvor:

- **Model/Data**: `data-loader.js` og `state.js` h√•ndterer datalagring og state
- **View**: `view-project-grid.js` og `view-viewer.js` h√•ndterer UI-rendering
- **Controller**: `main.js` og `router.js` koordinerer navigasjon og state-oppdateringer

### Hovedprinsipper

- **Statisk hosting**: Ingen server-side kode, alt kj√∏res i nettleseren
- **Ingen dependencies**: Ren HTML, CSS og JavaScript uten eksterne biblioteker
- **Modul√¶r struktur**: Hver fil har et klart ansvar
- **Hash-basert routing**: URL-struktur via hash-fragmenter for enkel hosting
- **localStorage**: Klient-side lagring av progresjon

## Komponentoversikt

### main.js
**Rolle**: Hovedkoordinator og applikasjonens entry point

**Ansvar**:
- Initialiserer router og state
- Koordinerer mellom routing, data-loading og view-rendering
- H√•ndterer applikasjonslivssyklus
- Kaller riktig view basert p√• rute

**Viktige funksjoner**:
- `init()` - Initialiserer applikasjonen
- `handleRoute(route)` - H√•ndterer ruteendringer og koordinerer rendering

**Viktig**: main.js gj√∏r **ikke** egen DOM-rendering. Den importerer og kaller `renderProjectGrid()` og `renderViewer()` fra view-modulene.

### router.js
**Rolle**: Hash-basert routing og URL-parsing

**Ansvar**:
- Lytter p√• `hashchange`-events
- Parser hash-fragmenter til Route-objekter
- Validerer og normaliserer URL-struktur
- Triggerer ruteendringer

**Route-typer**:

> **Merk**: Typedefinisjonene under er skrevet i TypeScript-lignende pseudokode for √• beskrive struktur, selv om prosjektet bruker vanlig JavaScript.

```javascript
type Route =
  | { type: "root" }
  | { type: "project"; path: string; stepIndex?: number };
```

**URL-eksempler**:
- `/#/` ‚Üí `{ type: "root" }`
- `/#/p/project1` ‚Üí `{ type: "project", path: "project1" }`
- `/#/p/project1?step=3` ‚Üí `{ type: "project", path: "project1", stepIndex: 3 }`

### state.js
**Rolle**: Tilstandsh√•ndtering (state management) og localStorage-integrasjon

**Ansvar**:
- Holder `AppState` i minne
- Synkroniserer med localStorage
- H√•ndterer progresjonslagring per prosjektpath
- Gir getters/setters for state

**AppState (minne)**:

> **Merk**: Typedefinisjonene under er skrevet i TypeScript-lignende pseudokode for √• beskrive struktur, selv om prosjektet bruker vanlig JavaScript.

`AppState` brukes i minne for √• beskrive hva som vises n√•:

```javascript
type AppState = {
  currentPath: string | null;      // f.eks. "project1" eller "project1/subproject-a"
  currentStepIndex: number;        // 0-basert indeks
  currentProjectMeta: ProjectMeta | null;
};
```

**Progresjonskart (localStorage)**:

Progresjon lagres separat som et kart i localStorage, med struktur:

```javascript
{
  "project1": 5,
  "project1/subproject-a": 2
}
```

Dette er ikke en del av `AppState`, men et separat objekt som lagrer siste steg per prosjektpath.

**Viktige funksjoner**:
- `loadProgress()` - Henter all lagret progresjon
- `saveProgress(map)` - Lagrer progresjon
- `getLastStepFor(path)` - Henter siste steg for en path
- `setStepFor(path, index)` - Setter steg for en path

### data-loader.js
**Rolle**: Datahenting fra JSON-filer

**Ansvar**:
- Henter `meta.json` for prosjekter/underprosjekter
- Henter `projects.json` for toppniv√•liste
- H√•ndterer async loading
- Gir feilh√•ndtering for manglende filer

**Viktige funksjoner**:
- `loadProjectMeta(path)` - Henter meta.json for en path
- `loadProjects()` - Henter projects.json
- `getImageUrl(path, imageName)` - Bygger URL til bilder

**Base URL**: `/projects/`

### view-project-grid.js
**Rolle**: Prosjektgalleri-view

**Ansvar**:
- Renderer grid/liste over prosjekter
- Viser cover-bilder og navn
- H√•ndterer klikk p√• prosjekter
- Viser progresjonsindikator (hvis implementert)
- Kan presentere underprosjekter inline (flatt galleri) f√∏r man navigerer videre, slik at barn slipper √• forst√• ‚Äúopp ett niv√•‚Äù

**DOM-struktur**:
- Container med grid-layout
- Prosjekt-tiles med cover-bilde og navn
- Event listeners for navigasjon

### view-viewer.js
**Rolle**: Instruksjonsviewer-view

**Ansvar**:
- Renderer instruksjonsbilde
- Initierer navigasjons-callbacks (main.js oppdaterer state/URL)
- Viser progresjonslinje
- H√•ndterer "opp"-knapp for hierarkisk navigasjon
- H√•ndterer tom steps-array (viser melding og deaktiverer kontroller)
- S√∏rger for at bildet fyller mest mulig av viewporten uten scroll og at nettleser-zoom fungerer
- Eksponerer ikon- og barnevennlige kontroller (store tap-targets, tydelig feedback)
- Viser vennlig loading-indikator (f.eks. LEGO-kloss-animajson) mens neste bilde lastes
- Feirer ferdigstillelse (konfetti/lyd) og markerer progresjon n√•r siste steg fullf√∏res
- Tilbyr lyd/haptikk-bryter og eventuelt steg-vis lydhint n√•r `audioSteps` er definert

**DOM-struktur**:
- Header (valgfritt)
- Image container (flex, fyller plass)
- Bottom bar med:
  - Tilbake-knapp
  - Venstre/h√∏yre-piler
  - Progresjonslinje
  - Steg-indikator ("Steg X av N")

**CSS-prinsipper**:
- Ingen scroll p√• image container
- Bildet skal `object-fit: contain` for √• tilpasse skjermen
- Responsivt design for mobil/nettbrett/PC

## Dataflyt

### Applikasjonsstart
1. `main.js` initialiserer router og state
2. Router parser initial hash
3. Basert p√• rute:
   - **Root**: `data-loader.js` henter `projects.json` ‚Üí `view-project-grid.js` renderer
   - **Project**: `data-loader.js` henter `meta.json` ‚Üí `state.js` setter state ‚Üí `view-viewer.js` renderer

### Navigasjon i prosjektgalleri
1. Bruker klikker p√• prosjekt
2. `view-project-grid.js` vurderer om prosjektet har underprosjekter:
   - I ‚Äúbarnemodus‚Äù vises underprosjekter inline med egne tiles (ingen hash-endring f√∏r barnet velger et konkret steg)
   - Hvis barnet velger et tile uten flere children, kalles callback som sender path til `main.js`
3. `main.js` oppdaterer `location.hash` via `updateHash()` n√•r det faktisk navigeres
4. Router fanger opp endring
5. `main.js` h√•ndterer ny rute
6. Data lastes og viewer renderes

**Onboarding**: F√∏rste gangs oppstart kan trigge en visuell ‚Äútrykk her‚Äù-overlegg i `view-project-grid.js` (maskot/piler) som peker p√• prosjekttiles. Overlegget skal kunne avbrytes umiddelbart og lagre flagg i localStorage slik at det ikke vises hver gang.

### Navigasjon mellom steg
1. Bruker klikker pil eller progresjonslinje
2. `view-viewer.js` kaller callback (f.eks. `onNextStep()`)
3. `main.js` mottar callback og:
   - Oppdaterer state via `updateState()`
   - Oppdaterer URL-hash via `updateHash()`
   - Lagrer progresjon til localStorage via `setStepFor()`
4. Router fanger opp hash-endring og trigger re-render
5. `view-viewer.js` re-renderer med nytt bilde fra oppdatert state

**Viktig**: Views gj√∏r IKKE direkte state/URL-oppdateringer. De kaller callbacks som sendes fra `main.js`, og `main.js` eier all state/URL-manipulasjon.

### Navigasjon opp i hierarkiet
1. Bruker klikker "Opp"-knapp
2. `view-viewer.js` kaller `onGoUp()` callback
3. `main.js` beregner forelder-path via `getParentPath()` og oppdaterer hash
4. Router h√•ndterer endring
5. Hvis forelder har egne bilder ‚Üí viser dem, ellers ‚Üí viser children-liste

## State Management

### AppState vs Progresjonskart

Det er viktig √• skille mellom to typer state:

1. **AppState** (i minne): Beskriver hva som vises n√•
   - Oppdateres kontinuerlig n√•r bruker navigerer
   - Holdes i minne, ikke lagret permanent
   - Inneholder n√•v√¶rende path, steg-indeks og prosjektmetadata

2. **Progresjonskart** (localStorage): Lagrer siste steg per prosjektpath
   - Lagres automatisk ved hver stegendring
   - Leses ved applikasjonsstart
   - Brukes for √• gjenoppta der brukeren slapp

### State-oppdateringer
`AppState` oppdateres gjennom `state.js` som gir kontrollerte metoder. **Views gj√∏r IKKE direkte state-oppdateringer**. I stedet:
- Views kaller callbacks (f.eks. `onNextStep()`, `onGoUp()`) som sendes fra `main.js`
- `main.js` eier all state/URL-manipulasjon og kaller `updateState()`, `updateHash()`, osv.
- Dette sikrer at all state-logikk er sentralisert i `main.js` og views forblir rene presentasjonskomponenter

### localStorage-synkronisering
Progresjon lagres automatisk ved hver stegendring. Formatet er enkel key-value hvor:
- **Key**: Prosjektpath (f.eks. `"project1/subproject-a"`)
- **Value**: Steg-indeks (nummer)

### State-persistence
Ved applikasjonsstart leses lagret progresjon fra localStorage. N√•r bruker navigerer til et prosjekt, brukes lagret steg hvis ingen steg er spesifisert i URL.

## Routing-system

### Hash-basert routing
Bruker hash-fragmenter (`#`) for routing siden dette ikke krever server-side konfigurasjon. Hash-endringer trigges ikke server-requests, perfekt for statisk hosting.

### URL-struktur
- **Root**: `/#/` eller `/#`
- **Prosjekt**: `/#/p/<path>`
- **Prosjekt med steg**: `/#/p/<path>?step=<index>`

### Routing-flyt
1. `window.addEventListener("hashchange")` fanger URL-endringer
2. `router.js` parser hash til Route-objekt
3. `main.js` mottar Route og bestemmer hvilket view som skal vises
4. Riktig data lastes og view renderes

**Eksempel p√• parsing** (illustrasjon, ikke fasit):

```javascript
// Eksempel p√• parsing av hash "#/p/project1/sub-a?step=3"
const hash = location.hash.slice(1); // "/p/project1/sub-a?step=3"
const [path, query] = hash.split('?');
const stepMatch = query?.match(/step=(\d+)/);
const stepIndex = stepMatch ? parseInt(stepMatch[1]) : undefined;
// Resultat: { type: "project", path: "project1/sub-a", stepIndex: 3 }
```

## Filstruktur

```
/lego-instruksjoner/
  index.html                 # Hoved-HTML-fil
  /assets/
    /css/
      main.css              # Hovedstiler
    /js/
      main.js               # Hovedkoordinator
      router.js             # Routing-logikk
      state.js              # State management
      view-project-grid.js   # Prosjektgalleri-view
      view-viewer.js        # Instruksjonsviewer-view
      data-loader.js        # Datahenting
  /projects/                # Prosjektdata
    project1/
      meta.json
      cover.png
      1_1x.png
      ...
  projects.json             # Toppniv√•liste
```

## Designvalg og begrunnelser

### Hash-basert routing
**Hvorfor**: Fungerer perfekt med statisk hosting, krever ingen server-konfigurasjon, og gir bookmarkable URLs.

### localStorage for progresjon
**Hvorfor**: Enkel, klient-side l√∏sning som ikke krever backend. Fungerer offline og gir rask tilgang.

### Modul√¶r struktur
**Hvorfor**: Gj√∏r koden lettere √• vedlikeholde, teste og utvide. Hver fil har klart ansvar.

### Ren JavaScript (ingen frameworks)
**Hvorfor**: Minimal overhead, enkel hosting, rask lasting, og full kontroll over implementasjonen.

### Ingen build tools
**Hvorfor**: Enklere setup, raskere utvikling, og direkte debugging i nettleseren.

## Skalerbarhet og vedlikehold

### Retningslinjer for filst√∏rrelse

#### N√•r en fil er for stor
En fil b√∏r vurderes for refaktorering n√•r:
- **Linjetall**: Over 400-500 linjer kode
- **Kompleksitet**: Flere ansvar som ikke naturlig h√∏rer sammen
- **Vedlikehold**: Vanskelig √• finne spesifikke funksjoner eller logikk
- **Testing**: Vanskelig √• teste isolert

#### Tegn p√• at en fil b√∏r deles opp
- Flere distinkte "seksjoner" i filen med ulike ansvar
- Gjentatt kode som kunne v√¶rt ekstrahert
- Flere store funksjoner (>50 linjer) som kunne v√¶rt egne moduler
- Vanskelig √• forst√• filens hovedansvar ved f√∏rste √∏yekast

### Refaktoreringsstrategier

#### Dele opp store filer

**Eksempel: Hvis `view-viewer.js` blir for stor**

1. **Identifiser ansvar**:
   - Bildevisning
   - Navigasjonskontroller
   - Progresjonslinje
   - Header/footer

2. **Ekstraher komponenter**:
   ```
   view-viewer.js          # Hovedkoordinator
   view-viewer-image.js    # Bildevisning
   view-viewer-controls.js # Navigasjonskontroller
   view-viewer-progress.js # Progresjonslinje
   ```

3. **Behold hovedfilen som koordinator**:
   - Hovedfilen importerer og koordinerer komponentene
   - Komponentene h√•ndterer sitt spesifikke ansvar

#### N√•r lage nye moduler

**Opprett ny modul n√•r**:
- Funksjonalitet brukes i flere filer (DRY-prinsipp)
- Funksjonalitet er kompleks nok til √• v√¶re egen enhet
- Funksjonalitet kan testes isolert
- Det gir klarere kodeorganisering

**Eksempler p√• nye moduler**:
- `utils.js` - Hjelpefunksjoner (formatering, validering, etc.)
- `image-utils.js` - Bildespesifikk logikk (preloading, caching)
- `navigation-utils.js` - Navigasjonshjelpefunksjoner

#### N√•r lage nye view-filer

**Opprett ny view n√•r**:
- Ny type visning trengs (f.eks. `view-detail.js` for detaljvisning)
- Eksisterende view blir for kompleks
- View har klart distinkt ansvar fra andre views

### Modulorganisering

#### View-filer
Alle view-filer skal f√∏lge samme m√∏nster:
- Eksporterer en hovedfunksjon som tar state/data som parameter
- Returnerer eller oppdaterer DOM-elementer
- H√•ndterer event listeners internt
- Kan ta imot callbacks for navigasjon/actions

**Eksempel struktur**:
```javascript
// view-example.js
import { getImageUrl } from './data-loader.js';

export function renderExample(data, onAction) {
  const container = document.createElement('div');
  container.className = 'example';
  // ... rendering logic
  // ... event listeners
  return container;
}
```

#### Utility-moduler
Utility-moduler skal:
- V√¶re pure functions hvor mulig
- Ha klare, beskrivende funksjonsnavn
- V√¶re testbare isolert
- Ikke ha sideeffekter (unntatt n√∏dvendig)

### Code Review Checklist

F√∏r du committer store endringer, vurder:

- [ ] Er filen under 500 linjer?
- [ ] Har hver funksjon et klart ansvar?
- [ ] Er koden testbar?
- [ ] Er det gjentatt kode som kunne ekstraherts?
- [ ] Er navngiving konsistent og beskrivende?
- [ ] Er kommentarer tilstrekkelige for kompleks logikk?
- [ ] F√∏lger koden eksisterende m√∏nstre i prosjektet?

### Vedlikeholdsrutiner

#### M√•nedlig review
- G√• gjennom st√∏rste filene i prosjektet
- Identifiser potensielle refaktoreringsmuligheter
- Dokumenter kompleksitet som vokser

#### Ved nye features
- Vurder om ny funksjonalitet passer i eksisterende filer
- Vurder om ny funksjonalitet krever ny modul
- Dokumenter nye patterns hvis de etableres

#### Ved refaktorering
- Oppdater denne dokumentasjonen hvis strukturen endres
- S√∏rg for at alle views/utilities f√∏lger samme m√∏nstre
- Test grundig etter refaktorering

### Eksempel: Refaktorering av stor fil

**F√∏r** (view-viewer.js - 600 linjer):
```javascript
// Alt i √©n fil: bildevisning, kontroller, progresjon, header, footer
export function renderViewer(state) {
  // 200 linjer bildevisning
  // 150 linjer kontroller
  // 100 linjer progresjon
  // 100 linjer header/footer
  // 50 linjer event handlers
}
```

**Etter** (modul√¶r struktur):
```javascript
// view-viewer.js (150 linjer) - Koordinator
import { renderImageViewer } from './view-viewer-image.js';
import { renderControls } from './view-viewer-controls.js';
import { renderProgress } from './view-viewer-progress.js';

export function renderViewer(state, callbacks) {
  const container = document.createElement('div');
  container.className = 'viewer';
  container.appendChild(renderImageViewer(state));
  container.appendChild(renderControls(state, callbacks));
  container.appendChild(renderProgress(state, callbacks));
  return container;
}

// view-viewer-image.js (100 linjer)
export function renderImageViewer(state) { /* ... */ }

// view-viewer-controls.js (80 linjer)
export function renderControls(state, callbacks) { /* ... */ }

// view-viewer-progress.js (70 linjer)
export function renderProgress(state, callbacks) { /* ... */ }
```

## Testing og debugging

### Debugging-tips
- Bruk browser DevTools for √• inspisere state
- Sjekk localStorage i Application-tab
- Bruk Network-tab for √• se datahenting
- Sett breakpoints i router for √• f√∏lge navigasjon

### Testing-strategi
Siden dette er et statisk prosjekt uten build tools:
- Manuell testing i nettleseren
- Test p√• ulike skjermst√∏rrelser
- Test localStorage-funksjonalitet
- Test navigasjon mellom alle views

## Fremtidige arkitekturforbedringer

### Potensielle utvidelser
- Service Worker for offline-st√∏tte
- Image caching-strategi
- Lazy loading av bilder
- Virtual scrolling for store prosjektlister
- TypeScript for type-sikkerhet (hvis kompleksitet vokser)

### N√•r vurdere st√∏rre endringer
- Hvis prosjektet vokser betydelig (>10 prosjekter, >1000 bilder)
- Hvis ytelse blir et problem
- Hvis vedlikehold blir vanskelig
- Hvis flere utviklere skal jobbe p√• prosjektet



--------------------------------------------------
File End
--------------------------------------------------


docs\CSS_GUIDELINES.md
File type: .md
# CSS Guidelines

Dette dokumentet beskriver CSS-struktur, styling-retningslinjer og design-prinsipper for LEGO Instruksjonsvisning-prosjektet.

## Retningslinjer for AI-generert CSS

N√•r AI foresl√•r ny CSS i dette prosjektet, gjelder:

- Bruk alltid eksisterende design tokens (`var(--color-...)`, `var(--spacing-...)`) i stedet for hardkodede verdier.
- F√∏lg BEM-lignende navngivning: `.block`, `.block__element`, `.block--modifier`.
- Ikke legg til nye farger uten √• f√∏rst definere dem som variabler i `:root`.
- Unng√• `!important` med mindre det er eksplisitt avtalt.
- Gjenbruk eksisterende utilities (`.u-flex`, `.u-text-center`, osv.) f√∏r du lager nye.
- Nye views skal f√∏lge m√∏nsteret fra `.project-grid` og `.viewer`.
- Utilities brukes sparsommelig. Hvis du gjentatte ganger trenger samme layout, vurder egen komponent-/layout-klasse framfor nye utilities.

## Filstruktur

CSS-organisering i `assets/css/main.css`:

```css
/* 1. CSS Variables / Design Tokens */
:root {
  /* Farger */
  /* Typografi */
  /* Spacing */
  /* Breakpoints */
}

/* 2. Reset / Normalize */
/* 3. Base styles */
/* 4. Layout components */
/* 5. View-specific styles */
/* 6. Utilities */
```

## Design Tokens

### CSS Variables

Definer alle design-tokens som CSS-variabler i `:root`:

```css
:root {
  /* Farger */
  --color-primary: #0066cc;
  --color-secondary: #666666;
  --color-background: #ffffff;
  --color-text: #333333;
  --color-border: #e0e0e0;
  --color-error: #cc0000;
  --color-success: #00cc00;
  
  /* Typografi */
  --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-size-base: 16px;
  --font-size-small: 14px;
  --font-size-large: 18px;
  --font-size-h1: 24px;
  --font-size-h2: 20px;
  --line-height-base: 1.5;
  
  /* Spacing */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  
  /* Breakpoints */
  /* Merk: Breakpoint-variabler brukes som dokumentasjon. Media-queries m√• fortsatt bruke tall direkte siden CSS-variabler ikke st√∏ttes i media queries i alle nettlesere. */
  --breakpoint-mobile: 375px;
  --breakpoint-tablet: 768px;
  --breakpoint-desktop: 1920px;
  
  /* Layout */
  --max-width-container: 1200px;
  --border-radius: 4px;
  --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
```

## Navngivingskonvensjon

### BEM-lignende struktur

Bruk BEM-lignende navngivning for komponenter:

```css
/* Block */
.project-grid { }
.project-tile { }

/* Block__Element */
.project-tile__image { }
.project-tile__name { }

/* Block--Modifier */
.project-grid--compact { }
.project-tile--active { }
```

**Viktig**: Hver komponent er sin egen block. `.project-grid` er container, `.project-tile` er en egen block som brukes i grid'en. Elementer tilh√∏rer sin n√¶rmeste block (f.eks. `.project-tile__image`, ikke `.project-grid__image`).

### Klassestruktur

- **Komponenter**: `.component-name` (f.eks. `.project-grid`, `.viewer`)
- **Elementer**: `.component-name__element` (f.eks. `.viewer__image`, `.viewer__controls`)
- **Modifikatorer**: `.component-name--modifier` (f.eks. `.button--primary`, `.tile--active`)
- **Utilities**: `.u-utility-name` (f.eks. `.u-hidden`, `.u-text-center`)

## Responsive Design

### Mobile-First Approach

Start med mobil-styling, legg til st√∏rre skjermer med media queries:

```css
/* Base (mobil) */
.container {
  padding: var(--spacing-md);
}

/* Tablet */
@media (min-width: 768px) {
  .container {
    padding: var(--spacing-lg);
  }
}

/* Desktop */
@media (min-width: 1920px) {
  .container {
    padding: var(--spacing-xl);
    max-width: var(--max-width-container);
    margin: 0 auto;
  }
}
```

### Breakpoints

Bruk definerte breakpoints:

```css
/* Mobil */
@media (min-width: 375px) { }

/* Nettbrett */
@media (min-width: 768px) { }

/* Desktop */
@media (min-width: 1920px) { }
```

## Layout-komponenter

### Prosjektgalleri (project-grid)

```css
.project-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: var(--spacing-md);
  padding: var(--spacing-md);
}

.project-tile {
  aspect-ratio: 1;
  border-radius: var(--border-radius);
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.project-tile:hover {
  transform: scale(1.05);
  box-shadow: var(--shadow);
}

.project-tile__image {
  width: 100%;
  height: 80%;
  object-fit: cover;
}

.project-tile__name {
  height: 20%;
  padding: var(--spacing-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--font-size-small);
  background: var(--color-background);
}
```

### Viewer (instruksjonsvisning)

```css
.viewer {
  display: flex;
  flex-direction: column;
  height: 100vh; /* Merk: P√• mobil kan 100vh gi litt ekstra scroll pga. browser UI, men dette er akseptabelt for dette prosjektet */
  overflow: hidden;
}

.viewer__header {
  padding: var(--spacing-md);
  background: var(--color-background);
  border-bottom: 1px solid var(--color-border);
  font-size: var(--font-size-large);
  font-weight: bold;
}

.viewer__main {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  background: var(--color-background);
  padding: var(--spacing-md);
}

.viewer__main img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.viewer__loading {
  width: 120px;
  height: 120px;
  border-radius: 12px;
  background: var(--color-background);
  box-shadow: var(--shadow);
  display: flex;
  align-items: center;
  justify-content: center;
  animation: bounce 1s infinite;
}

.viewer__loading-icon {
  width: 64px;
  height: 64px;
  background-image: url('../img/loading-brick.svg'); /* Placeholder ‚Äì bytt til faktisk ressurs */
  background-size: contain;
  background-repeat: no-repeat;
  animation: spin 1.8s linear infinite;
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-8px); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* 
 * Maksimal bildeflate - viktige prinsipper:
 * 
 * 1. Container (.viewer__main) skal IKKE ha hard width/height
 *    - Bruk flex: 1 for √• fylle tilgjengelig plass
 *    - La h√∏yden bestemmes av viewport og flex-layout
 * 
 * 2. Bildet skal bruke object-fit: contain
 *    - Sikrer at hele bildet vises uten √• kuttes
 *    - Beholder aspect ratio
 * 
 * 3. max-width/height: 100% p√• bildet
 *    - Sikrer at bildet ikke overstiger containeren
 *    - Fungerer sammen med object-fit: contain
 * 
 * 4. Zoom-mekanisme:
 *    - Browser zoom (Ctrl/Cmd +, Ctrl/Cmd -) er anbefalt zoom-mekanisme
 *    - Bildet skal v√¶re zoombart via standard nettleser-funksjonalitet
 *    - IKKE bruk pointer-events: none p√• bildet (blokkerer zoom)
 *    - Hvis custom zoom skal implementeres senere:
 *      * Bruk transform: scale() p√• bildet direkte
 *      * IKKE endre container-st√∏rrelse (width/height)
 *      * Behold flex-layout for responsivitet
 */

.viewer__bottom {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  padding: var(--spacing-md);
  background: var(--color-background);
  border-top: 1px solid var(--color-border);
}

.viewer__button {
  padding: var(--spacing-sm) var(--spacing-md);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius);
  background: var(--color-background);
  cursor: pointer;
  font-size: var(--font-size-base);
}

.viewer__button:hover:not(:disabled) {
  background: var(--color-primary);
  color: white;
}

.viewer__button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.viewer__progress {
  flex: 1;
  height: 8px;
}

.viewer__step-indicator {
  font-size: var(--font-size-small);
  color: var(--color-secondary);
}
```

## Base Styles

### Reset og Normalize

```css
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  font-family: var(--font-family-base);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--color-text);
  background: var(--color-background);
}

img {
  max-width: 100%;
  height: auto;
  display: block;
}

button {
  font-family: inherit;
  font-size: inherit;
  border: none;
  background: none;
  cursor: pointer;
}

a {
  color: var(--color-primary);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
```

## Utilities

### Utility Classes

Utilities brukes sparsommelig. Hvis du gjentatte ganger trenger samme layout, vurder egen komponent-/layout-klasse framfor nye utilities.

```css
/* Display */
.u-hidden {
  display: none !important;
}

.u-flex {
  display: flex !important;
}

.u-grid {
  display: grid !important;
}

/* Text alignment */
.u-text-center {
  text-align: center !important;
}

.u-text-left {
  text-align: left !important;
}

.u-text-right {
  text-align: right !important;
}

/* Spacing */
.u-margin-sm {
  margin: var(--spacing-sm) !important;
}

.u-margin-md {
  margin: var(--spacing-md) !important;
}

.u-padding-sm {
  padding: var(--spacing-sm) !important;
}

.u-padding-md {
  padding: var(--spacing-md) !important;
}
```

## Responsive Patterns

### Grid Layout

```css
/* Mobil: 1 kolonne */
.grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-md);
}

/* Tablet: 2 kolonner */
@media (min-width: 768px) {
  .grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Desktop: 3 kolonner */
@media (min-width: 1920px) {
  .grid {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

### Flexbox Layout

```css
.flex-container {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

@media (min-width: 768px) {
  .flex-container {
    flex-direction: row;
  }
}
```

## Bildestyling

### Prim√¶rt m√∏nster: Komponent-klasser

I viewer og andre komponenter bruker vi hovedsakelig komponent-klasser:

```css
.viewer__main img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}
```

### Valgfrie hjelpeklasser

`.instruction-image` og `.cover-image` er valgfrie hjelpeklasser som kan brukes hvis vi har bilder utenfor viewer/galleri:

```css
.instruction-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
  object-position: center;
}

.cover-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
}
```

**Regel**: Prefer komponent-klasser (`.viewer__main img`) over globale semantics-klasser n√•r mulig.

## Interaktivitet

### Hover States

```css
.interactive-element {
  transition: transform 0.2s, opacity 0.2s;
}

.interactive-element:hover {
  transform: scale(1.05);
  opacity: 0.9;
}
```

### Focus States

```css
button:focus,
a:focus {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}
```

### Active States

```css
button:active {
  transform: scale(0.95);
}
```

## Progresjonslinje

### Range Input Styling

```css
input[type="range"] {
  width: 100%;
  height: 8px;
  border-radius: 4px;
  background: var(--color-border);
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--color-primary);
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--color-primary);
  cursor: pointer;
  border: none;
}
```

## Mobile-Specific Styles

### Touch Targets

S√∏rg for at klikkbare elementer er store nok for touch:

```css
.touch-target {
  min-height: 44px;
  min-width: 44px;
  padding: var(--spacing-sm);
}
```

### Viewport Meta

Husk √• inkludere i HTML:

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

## Beste Praksis

### 1. Bruk CSS Variables

```css
/* ‚úÖ Bra */
.button {
  background: var(--color-primary);
  padding: var(--spacing-md);
}

/* ‚ùå D√•rlig */
.button {
  background: #0066cc;
  padding: 16px;
}
```

### 2. Mobile-First

```css
/* ‚úÖ Bra - starter med mobil */
.container {
  padding: var(--spacing-sm);
}

@media (min-width: 768px) {
  .container {
    padding: var(--spacing-md);
  }
}

/* ‚ùå D√•rlig - starter med desktop */
.container {
  padding: var(--spacing-lg);
}

@media (max-width: 767px) {
  .container {
    padding: var(--spacing-sm);
  }
}
```

### 3. BEM-lignende Navngivning

```css
/* ‚úÖ Bra - project-tile er egen block, s√• modifikator g√•r p√• tile */
.project-tile--active { }

/* ‚ùå D√•rlig - project-tile er ikke element av project-grid */
.project-grid__tile--active { }

/* ‚ùå D√•rlig */
.activeTile { }
.tileActive { }
```

**Merk**: `.project-tile` er en egen block, ikke et element av `.project-grid`. Derfor brukes `.project-tile--active`, ikke `.project-grid__tile--active`.

### 4. Unng√• !important

Bruk spesifisitet i stedet:

```css
/* ‚úÖ Bra */
.viewer .button {
  color: red;
}

/* ‚ùå D√•rlig */
.button {
  color: red !important;
}
```

### 5. Organiser CSS Logisk

```css
/* 1. Variables */
:root { }

/* 2. Base */
body { }
img { }

/* 3. Layout */
.container { }
.grid { }

/* 4. Components */
.project-grid { }
.viewer { }

/* 5. Utilities */
.u-hidden { }
```

### 6. Z-index Retningslinjer

N√•r du bruker z-index, f√∏lg denne policyen:

```css
/* 10-19: Faste elementer (header, bottom-bar) */
.viewer__header {
  z-index: 10;
}

.viewer__bottom {
  z-index: 10;
}

/* 20-29: Overlays (loading, dimming) */
.loading-overlay {
  z-index: 20;
}

/* 30-39: Modaler / dialoger */
.modal {
  z-index: 30;
}

/* Unng√• √• bruke z-index > 40 */
```

### Barnevennlig UI (5‚Äì7 √•r)

- **Ikoner foran tekst**: Anta at brukeren ikke kan lese flytende. Navigasjonsknapper (opp/hjem, neste/forrige, progresjonsindikator) skal bruke tydelige symboler (hus, piler, stjerner) og kan st√∏ttes av tall (f.eks. `3/10`) i stedet for tekststrenger som ‚ÄúSteg 3 av 10‚Äù.
- **Store trykkflater**: Minimum 44x44px er absolutt minimum; sikte p√• ~64px (ca. 2 cm) for prim√¶rknapper slik at sm√• fingre treffer riktig. S√∏rg for minst `var(--spacing-md)` mellom interaktive elementer.
- **Plassering**: Neste/forrige-knapper kan up-skaleres og trekkes ut mot venstre/h√∏yre hj√∏rne av `.viewer__bottom` slik at de ikke konkurrerer med progressbar. Opp/hjem-knapp plasseres konsekvent (typisk √∏verst til venstre) for muskelminne.
- **Farger og feedback**: Bruk klare, h√∏y-kontrast LEGO-inspirerte farger p√• interaktive elementer. Alle knapper skal ha en aktiv/trykket-state (lys opp, skift farge, animasjon) slik at barn ser at trykket ble registrert.
- **Lyd og animasjoner (valgfritt)**: Hvis UI-et utvides med lyd/animert feedback, reserver plass til et diskret ‚Äúlyd av/p√•‚Äù-ikon og s√∏rg for at animasjoner er korte (<300ms) for √• holde tempoet oppe.
- **Progresjonslinje**: Visuell indikator kan v√¶re en tykk bar eller en serie symboler. Dragging er sekund√¶r; prim√¶rnavigasjonen er pilene, s√• progressbaren skal st√∏ttes via store tap-targets eller segmenter.
- **Tom-state og bel√∏nning**: N√•r et prosjekt mangler steg, vis en vennlig illustrasjon (f.eks. minifigur) som sier ‚Äúkommer snart‚Äù. Ved fullf√∏rt prosjekt kan `.viewer__bottom` trigge en konfetti- eller stjerneanimert klasse for √• feire ferdigstillelse.
- **Loading-indikator**: Bruk LEGO-inspirert spinner (`.viewer__loading`) med myk animasjon mens bilder lastes. Den skal v√¶re barnlig og tydelig (ingen sm√• spinnere).
- **Onboarding-overlay**: Definer `.onboarding-overlay` (fullskjerm, semitransparent) med en maskot/figur som peker p√• galleri-tiles. Bruk sterke farger og en enkel puls/peke-animasjon.
- **Bel√∏nning/badges**: For prosjekt fullf√∏rt, bruk `.viewer__celebration` som legger til konfetti (CSS animasjon) eller stjerne-illustrasjon, eventuelt kombinert med en liten lyd hvis sl√•tt p√•.

```css
.onboarding-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.35);
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

.onboarding-overlay__mascot {
  width: 220px;
  height: 220px;
  background-image: url('../img/mascot.png');
  background-size: contain;
  animation: wiggle 1.2s ease-in-out infinite;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes wiggle {
  0%, 100% { transform: rotate(0deg); }
  25% { transform: rotate(4deg); }
  75% { transform: rotate(-4deg); }
}
```

## Testing

### Test p√• ulike skjermst√∏rrelser

1. **Mobil**: 375px (iPhone SE)
2. **Nettbrett**: 768px (iPad)
3. **Desktop**: 1920px (Full HD)

### Test i DevTools

- Bruk Device Mode i Chrome DevTools
- Test b√•de portrait og landscape
- Test touch-interaksjoner

### Sjekkliste

- [ ] Alle elementer er synlige p√• mobil
- [ ] Tekst er lesbar p√• alle skjermst√∏rrelser
- [ ] Klikkbare elementer er store nok (min 44x44px)
- [ ] Bilder tilpasses skjermen korrekt
- [ ] Ingen horizontal scrolling
- [ ] Focus states er synlige
- [ ] Hover states fungerer (p√• desktop)



--------------------------------------------------
File End
--------------------------------------------------


docs\DATA_FORMAT.md
File type: .md
# Data Format

Dette dokumentet beskriver i detalj JSON-formatene som brukes i LEGO Instruksjonsvisning-prosjektet.

## Oversikt

Prosjektet bruker to hovedtyper JSON-filer:
- **`meta.json`**: Metadata for hvert prosjekt/underprosjekt
- **`projects.json`**: Liste over toppniv√•-prosjekter

## meta.json

`meta.json`-filer beskriver metadata for et prosjekt eller underprosjekt. Hver prosjektmappe skal ha en `meta.json`-fil.

### Struktur

```json
{
  "id": "string",
  "name": "string",
  "coverImage": "string",
  "steps": ["string"],
  "children": [
    {
      "id": "string",
      "name": "string",
      "path": "string"
    }
  ]
}
```

### Felter

#### `id` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Unik identifikator for prosjektet/underprosjektet
- **Eksempler**: `"castle-main"`, `"castle-tower"`, `"mitt-prosjekt"`
- **Regler**:
  - M√• v√¶re unik innenfor samme niv√•
  - Anbefales √• bruke kebab-case (sm√• bokstaver med bindestrek)
  - Ikke bruk mellomrom eller spesialtegn

#### `name` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Visningsnavn som vises i brukergrensesnittet
- **Eksempler**: `"Stor borg"`, `"T√•rn"`, `"Mitt Prosjekt"`
- **Regler**:
  - Kan inneholde mellomrom og norske tegn (√¶, √∏, √•)
  - Dette er det navnet brukeren ser

#### `coverImage` (valgfritt)
- **Type**: String
- **Beskrivelse**: Filnavn p√• cover-bildet som brukes i prosjektgalleriet
- **Eksempler**: `"cover.png"`, `"1_cover.png"`
- **Regler**:
  - Hvis ikke spesifisert eller bildet ikke finnes, brukes det f√∏rste bildet (laveste nummer)
  - M√• v√¶re et filnavn som finnes i samme mappe
  - Anbefales √• bruke `"cover.png"` for konsistens

#### `steps` (p√•krevd)
- **Type**: Array of strings
- **Beskrivelse**: Liste over alle steg-bildene i riktig rekkef√∏lge
- **Eksempler**: 
  ```json
  ["1_1x.png", "2_1x.png", "3_1x.png"]
  ```
- **Regler**:
  - M√• v√¶re en array
  - Kan v√¶re tom array `[]` hvis prosjektet ikke har steg-bilder (f.eks. kun underprosjekter)
  - Hvis tom: viewer viser "Ingen steg tilgjengelig" og deaktiverer navigasjonskontroller
  - Filnavnene m√• matche faktiske filer i mappen
  - Rekkef√∏lgen i arrayet bestemmer visningsrekkef√∏lgen
  - Bildene sorteres automatisk basert p√• nummeret i filnavnet (se README.md)

#### `children` (p√•krevd)
- **Type**: Array of objects
- **Beskrivelse**: Liste over underprosjekter
- **Eksempler**: 
  ```json
  [
    {
      "id": "castle-tower",
      "name": "T√•rn",
      "path": "subproject-tower"
    },
    {
      "id": "castle-gate",
      "name": "Port",
      "path": "subproject-gate"
    }
  ]
  ```
- **Regler**:
  - M√• v√¶re en array, selv om den er tom (`[]`)
  - Hvert objekt m√• ha `id`, `name` og `path`
  - `path` er relativ sti til undermappen (se nedenfor)

#### `audioSteps` (valgfritt)
- **Type**: Array of strings
- **Beskrivelse**: Lydfiler (en per steg) som kan spilles av i viewer for muntlig hjelp
- **Eksempler**:
  ```json
  "audioSteps": ["audio/1.mp3", "audio/2.mp3", "audio/3.mp3"]
  ```
- **Regler**:
  - Lengden b√∏r samsvare med `steps`. Manglende elementer betyr ‚Äúingen lyd‚Äù.
  - Filene m√• ligge i samme mappe eller en `audio/`-undermappe slik at URL bygges som `/projects/{path}/{audioSteps[i]}`
  - Filformat b√∏r v√¶re `.mp3` eller `.ogg` for bred st√∏tte

#### `children[].id` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Unik identifikator for underprosjektet
- **Regler**: Samme regler som toppniv√• `id`

#### `children[].name` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Visningsnavn for underprosjektet
- **Regler**: Samme regler som toppniv√• `name`

#### `children[].path` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Relativ sti til undermappen fra hovedprosjektmappen
- **Eksempler**: 
  - Hvis undermappen heter `t√•rn/` og ligger i `/projects/castle-main/t√•rn/`, settes `path` til `"t√•rn"`
  - Hvis undermappen heter `subproject-tower/`, settes `path` til `"subproject-tower"`
- **Regler**:
  - M√• v√¶re navnet p√• undermappen (uten trailing slash)
  - M√• matche faktisk mappestruktur
  - Relativ fra hovedprosjektmappen, ikke absolutt sti
  - Brukes til √• bygge full sti: `/projects/{hovedprosjekt-path}/{path}/meta.json`

#### `children[].hidden` (valgfritt)
- **Type**: Boolean
- **Beskrivelse**: Hvis `true`, skjules underprosjektet fra visning i children-liste
- **Eksempler**: `true`, `false`
- **Regler**:
  - Hvis ikke spesifisert eller `false`, vises underprosjektet normalt
  - Hvis `true`, skjules det fra children-listen i viewer
  - Skjulte underprosjekter er fortsatt tilgjengelige via direkte URL
  - Brukes for √• skjule uferdige eller private underprosjekter

### Eksempler

#### Prosjekt uten underprosjekter

```json
{
  "id": "castle-tower",
  "name": "T√•rn",
  "coverImage": "cover.png",
  "steps": [
    "1_1x.png",
    "2_1x.png",
    "3_1x.png"
  ],
  "children": []
}
```

#### Prosjekt med underprosjekter

```json
{
  "id": "castle-main",
  "name": "Stor borg",
  "coverImage": "cover.png",
  "steps": [
    "step-001.png",
    "step-002.png",
    "step-003.png"
  ],
  "children": [
    {
      "id": "castle-tower",
      "name": "T√•rn",
      "path": "subproject-tower"
    },
    {
      "id": "castle-gate",
      "name": "Port",
      "path": "subproject-gate",
      "hidden": true
    }
  ]
}
```

#### Prosjekt med egne bilder og underprosjekter

Et prosjekt kan ha b√•de egne steg-bilder og underprosjekter:

```json
{
  "id": "house-main",
  "name": "Huset V√•rt",
  "coverImage": "cover.png",
  "steps": [
    "174_1x.png",
    "175_1x.png",
    "176_1x.png",
    "177_1x.png",
    "178_1x.png",
    "179_1x.png"
  ],
  "children": [
    {
      "id": "spiserom",
      "name": "1-Spiserom",
      "path": "1-Spiserom"
    },
    {
      "id": "alma-rom",
      "name": "2-Alma sitt Rom",
      "path": "2-Alma sitt Rom"
    }
  ]
}
```

## projects.json

`projects.json` ligger i rotmappen og lister alle toppniv√•-prosjekter.

### Struktur

```json
[
  {
    "id": "string",
    "name": "string",
    "path": "string"
  }
]
```

### Felter

#### `id` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Unik identifikator for prosjektet
- **Regler**: Samme regler som `meta.json` `id`
- **Viktig**: M√• matche `id` i prosjektets `meta.json`

#### `name` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Visningsnavn for prosjektet
- **Regler**: Samme regler som `meta.json` `name`
- **Viktig**: M√• matche `name` i prosjektets `meta.json` (anbefalt, men ikke p√•krevd)

#### `path` (p√•krevd)
- **Type**: String
- **Beskrivelse**: Relativ sti til prosjektmappen fra `/projects/`
- **Eksempler**: 
  - Hvis prosjektet ligger i `/projects/castle-main/`, settes `path` til `"castle-main"`
  - Hvis prosjektet ligger i `/projects/mitt-prosjekt/`, settes `path` til `"mitt-prosjekt"`
- **Regler**:
  - M√• v√¶re navnet p√• prosjektmappen (uten trailing slash)
  - M√• matche faktisk mappestruktur
  - Relativ fra `/projects/`, ikke absolutt sti
  - Brukes til √• bygge full sti: `/projects/{path}/meta.json`

#### `hidden` (valgfritt)
- **Type**: Boolean
- **Beskrivelse**: Hvis `true`, skjules prosjektet fra prosjektgalleri
- **Eksempler**: `true`, `false`
- **Regler**:
  - Hvis ikke spesifisert eller `false`, vises prosjektet normalt i galleri
  - Hvis `true`, skjules det fra prosjektgalleri
  - Skjulte prosjekter er fortsatt tilgjengelige via direkte URL
  - Brukes for √• skjule uferdige eller private prosjekter

### Eksempel

```json
[
  {
    "id": "project1",
    "name": "Stor borg",
    "path": "project1"
  },
  {
    "id": "project2",
    "name": "Uferdig prosjekt",
    "path": "project2",
    "hidden": true
  },
  {
    "id": "project3",
    "name": "Romskip",
    "path": "project3"
  },
  {
    "id": "house-main",
    "name": "Huset V√•rt",
    "path": "Huset V√•rt"
  }
]
```

## Sti-bygging

### Hvordan stier bygges

1. **Toppniv√•-prosjekt**:
   - Fra `projects.json`: `path = "castle-main"`
   - Full sti: `/projects/castle-main/meta.json`

2. **Underprosjekt**:
   - Fra `projects.json`: `path = "castle-main"`
   - Fra `meta.json` children: `path = "subproject-tower"`
   - Full sti: `/projects/castle-main/subproject-tower/meta.json`

3. **Bilde-URL**:
   - Prosjekt: `/projects/castle-main/`
   - Bilde: `1_1x.png`
   - Full URL: `/projects/castle-main/1_1x.png`

### Eksempel p√• komplett hierarki

```
/projects/
  castle-main/
    meta.json          # id: "castle-main", children: [{id: "tower", path: "tower"}]
    cover.png
    1_1x.png
    2_1x.png
    tower/
      meta.json        # id: "tower", children: []
      cover.png
      1_1x.png
      2_1x.png

projects.json:
[
  {id: "castle-main", name: "Stor borg", path: "castle-main"}
]
```

## Validering

### P√•krevde felt

Alle f√∏lgende felt er p√•krevd og m√• v√¶re tilstede:

**meta.json**:
- `id`
- `name`
- `steps` (kan v√¶re tom array)
- `children` (kan v√¶re tom array)

**projects.json**:
- Hvert objekt m√• ha `id`, `name`, og `path`

### Valideringsregler

1. **Unike ID-er**: `id` m√• v√¶re unik innenfor samme niv√•
2. **Matchende stier**: `path` i `projects.json` og `children` m√• matche faktiske mapper
3. **Eksisterende filer**: Alle filnavn i `steps` og `coverImage` m√• referere til faktiske filer
4. **Gyldig JSON**: Alle filer m√• v√¶re gyldig JSON
5. **Array-typer**: `steps` og `children` m√• v√¶re arrays, selv om de er tomme

### Feilh√•ndtering

Hvis en `meta.json` eller `projects.json` er ugyldig:
- Applikasjonen vil pr√∏ve √• h√•ndtere feilen gracefully
- Feilmeldinger vises i konsollen
- Manglende prosjekter vil ikke vises i galleriet

## Beste praksis

### Navngiving

- **ID-er**: Bruk kebab-case (`castle-main`, `spiserom`)
- **Navn**: Bruk lesbare navn med mellomrom (`"Stor borg"`, `"Alma sitt Rom"`)
- **Paths**: Bruk samme navn som mappen (kan v√¶re forskjellig fra `id`)

### Organisering

- Hold `meta.json` og `projects.json` synkronisert
- Bruk konsistent navngiving for bilder (`1_1x.png`, `2_1x.png`, etc.)
- Organiser underprosjekter logisk i mapper

### Vedlikehold

- Oppdater `projects.json` n√•r nye prosjekter legges til
- S√∏rg for at alle `path`-referanser er korrekte
- Test at alle bilder eksisterer etter endringer

## Eksempel p√• komplett oppsett

### Filstruktur

```
/projects/
  castle-main/
    meta.json
    cover.png
    1_1x.png
    2_1x.png
    tower/
      meta.json
      cover.png
      1_1x.png
      2_1x.png
  spaceship/
    meta.json
    cover.png
    1_1x.png
    2_1x.png
    3_1x.png

projects.json
```

### projects.json

```json
[
  {
    "id": "castle-main",
    "name": "Stor borg",
    "path": "castle-main"
  },
  {
    "id": "spaceship",
    "name": "Romskip",
    "path": "spaceship"
  }
]
```

### /projects/castle-main/meta.json

```json
{
  "id": "castle-main",
  "name": "Stor borg",
  "coverImage": "cover.png",
  "steps": [
    "1_1x.png",
    "2_1x.png"
  ],
  "children": [
    {
      "id": "tower",
      "name": "T√•rn",
      "path": "tower"
    }
  ]
}
```

### /projects/castle-main/tower/meta.json

```json
{
  "id": "tower",
  "name": "T√•rn",
  "coverImage": "cover.png",
  "steps": [
    "1_1x.png",
    "2_1x.png"
  ],
  "children": []
}
```

### /projects/spaceship/meta.json

```json
{
  "id": "spaceship",
  "name": "Romskip",
  "coverImage": "cover.png",
  "steps": [
    "1_1x.png",
    "2_1x.png",
    "3_1x.png"
  ],
  "children": []
}
```



--------------------------------------------------
File End
--------------------------------------------------


docs\IMPLEMENTATION.md
File type: .md
# Implementasjonsguide

Dette dokumentet beskriver hvordan koden skal implementeres, inkludert funksjonssignaturer, patterns og konvensjoner.

## Hvordan denne guiden skal brukes (for AI)

- F√∏lg funksjonssignaturene og typedefs som fasit; ikke finn opp egne varianter.
- Bruk samme modulansvar som beskrevet (main koordinerer, views bygger DOM, data-loader fetcher).
- Ikke legg til nye globale m√∏nstre (f.eks. nye navngivningskonvensjoner) uten √• oppdatere denne filen.
- N√•r du foresl√•r endringer p√• tvers av moduler, s√∏rg for at Implementation.md oppdateres samtidig.
- Bruk klassnavn som matcher [CSS_GUIDELINES.md](./CSS_GUIDELINES.md) - f.eks. `.viewer__header`, ikke `.viewer-header`.
- state.js eksporteres som enkeltfunksjoner, ikke som et state-objekt.

## Generelle prinsipper

### Kode-stil
- Bruk moderne JavaScript (ES6+)
- Bruk `const` og `let`, unng√• `var`
- Bruk arrow functions hvor det gir mening
- Bruk template literals for string-interpolasjon
- Hold funksjoner korte og fokuserte (maks 50 linjer per funksjon)

### Modulstruktur
- Hver fil skal v√¶re en ES6-modul med `export`
- Bruk named exports, ikke default exports
- Hver modul skal ha et klart ansvar

### Navngiving
- Funksjoner: camelCase (`loadProjectMeta`, `renderViewer`)
- Konstanter: UPPER_SNAKE_CASE (`BASE_URL`, `STORAGE_KEY`)
- Filer: kebab-case (`view-viewer.js`, `data-loader.js`)

## Modul-implementasjoner

### main.js

**Rolle**: Hovedkoordinator som kobler alt sammen. main.js skal **ikke** gj√∏re egen DOM-rendering - den kaller view-funksjoner fra view-moduler og monterer dem i root-containeren.

**Eksporterte funksjoner**:

```javascript
/**
 * Initialiserer applikasjonen
 * Kalles √©n gang n√•r siden laster
 */
export function init() {
  // Initialiser router
  // Initialiser state
  // H√•ndter initial route
}

/**
 * H√•ndterer ruteendringer
 * @param {Route} route - Route-objekt fra router
 */
export function handleRoute(route) {
  // Basert p√• route.type:
  // - "root" ‚Üí last projects.json og render projectGrid
  // - "project" ‚Üí last meta.json og render viewer
}

```

**Viktig**: main.js skal importere render-funksjoner fra view-modulene, ikke implementere dem selv:

```javascript
import { renderProjectGrid } from './view-project-grid.js';
import { renderViewer } from './view-viewer.js';
```

**Viktig**: main.js eier all state/URL-manipulasjon. Views kaller callbacks som sendes fra main.js, og main.js h√•ndterer alle state-oppdateringer og URL-endringer.

**Eksempel p√• init()**:

```javascript
import { init as initRouter, parseHash, updateHash, getParentPath } from './router.js';
import { loadProjects } from './data-loader.js';
import { getState, updateState, getLastStepFor } from './state.js';
import { loadProjectMeta } from './data-loader.js';
import { renderProjectGrid } from './view-project-grid.js';
import { renderViewer } from './view-viewer.js';

export function init() {
  // Initialiser router
  initRouter((route) => {
    handleRoute(route);
  });
  
  // H√•ndter initial route
  const initialRoute = parseHash(window.location.hash);
  handleRoute(initialRoute);
}
```

**Eksempel p√• handleRoute() - hel flyt**:

```javascript
export async function handleRoute(route) {
  const root = document.getElementById('app');
  root.innerHTML = '';

  if (route.type === 'root') {
    // Last prosjekter og render galleri
    const projects = await loadProjects();
    const grid = renderProjectGrid(projects, (path) => {
      updateHash({ type: 'project', path });
    });
    root.appendChild(grid);
  } else if (route.type === 'project') {
    // Last prosjektmetadata
    const meta = await loadProjectMeta(route.path);
    const lastStep = route.stepIndex ?? getLastStepFor(route.path);
    
    // Oppdater state
    updateState({
      currentPath: route.path,
      currentStepIndex: lastStep,
      currentProjectMeta: meta
    });
    
    // Render viewer med callbacks
    const viewer = renderViewer(getState(), {
      onPrevStep: () => {
        const state = getState();
        const newIndex = Math.max(0, state.currentStepIndex - 1);
        updateState({ currentStepIndex: newIndex });
        updateHash({ type: 'project', path: state.currentPath, stepIndex: newIndex });
      },
      onNextStep: () => {
        const state = getState();
        const maxIndex = (state.currentProjectMeta?.steps.length || 1) - 1;
        const newIndex = Math.min(maxIndex, state.currentStepIndex + 1);
        updateState({ currentStepIndex: newIndex });
        updateHash({ type: 'project', path: state.currentPath, stepIndex: newIndex });
      },
      onStepChange: (stepIndex) => {
        updateState({ currentStepIndex: stepIndex });
        const { currentPath } = getState();
        updateHash({ type: 'project', path: currentPath, stepIndex });
      },
      onGoUp: () => {
        const { currentPath } = getState();
        const parentPath = getParentPath(currentPath);
        if (parentPath) {
          updateHash({ type: 'project', path: parentPath });
        } else {
          updateHash({ type: 'root' });
        }
      }
    });
    root.appendChild(viewer);
  }
}
```

### router.js

**Rolle**: Hash-basert routing og URL-parsing

**Eksporterte funksjoner**:

```javascript
/**
 * Route-objekt struktur
 * @typedef {Object} Route
 * @property {"root"|"project"} type - Type rute
 * @property {string} [path] - Prosjektpath (kun for "project")
 * @property {number} [stepIndex] - Steg-indeks (kun for "project")
 */

/**
 * Initialiserer router
 * @param {function(Route): void} onRouteChange - Callback n√•r rute endres
 */
export function init(onRouteChange) {
  // Legg til hashchange listener
  // Kall onRouteChange ved endringer
}

/**
 * Parser hash-fragment til Route-objekt
 * @param {string} hash - Hash-fragment (f.eks. "#/p/project1?step=3")
 * @returns {Route} Route-objekt
 */
export function parseHash(hash) {
  // Parse hash til Route-objekt
  // Returner { type: "root" } eller { type: "project", path: "...", stepIndex: ... }
}

/**
 * Oppdaterer URL-hash basert p√• Route
 * @param {Route} route - Route-objekt
 */
export function updateHash(route) {
  // Bygg hash-string fra Route
  // Oppdater window.location.hash
}

/**
 * Beregner forelder-path fra en gitt path
 * @param {string|null} path - Prosjektpath (f.eks. "project1/sub-a")
 * @returns {string|null} Forelder-path eller null hvis ingen forelder
 */
export function getParentPath(path) {
  if (!path) return null;
  const parts = path.split('/');
  parts.pop();
  return parts.join('/') || null;
}
```

**Eksempel p√• parseHash()**:

```javascript
export function parseHash(hash) {
  // Fjern # fra starten
  const path = hash.slice(1);
  
  // Hvis tom eller bare "/", returner root
  if (!path || path === '/') {
    return { type: 'root' };
  }
  
  // Parse "/p/project1/sub-a?step=3"
  const match = path.match(/^\/p\/(.+?)(?:\?step=(\d+))?$/);
  if (!match) {
    return { type: 'root' }; // Fallback til root ved ugyldig hash
  }
  
  return {
    type: 'project',
    path: match[1],
    stepIndex: match[2] ? parseInt(match[2], 10) : undefined
  };
}
```

### state.js

**Rolle**: State management og localStorage-integrasjon

**Viktig**: state.js inneholder ett modul-globalt `let appState`-objekt. `updateState()` muterer dette og returnerer den nye staten. Eventuell re-render styres av main.js.

**Eksporterte funksjoner**:

```javascript
/**
 * AppState struktur
 * @typedef {Object} AppState
 * @property {string|null} currentPath - N√•v√¶rende prosjektpath
 * @property {number} currentStepIndex - N√•v√¶rende steg-indeks (0-basert)
 * @property {ProjectMeta|null} currentProjectMeta - N√•v√¶rende prosjektmetadata
 */

/**
 * Henter n√•v√¶rende AppState
 * @returns {AppState} N√•v√¶rende state
 */
export function getState() {
  // Returner n√•v√¶rende AppState
}

/**
 * Oppdaterer AppState
 * @param {Partial<AppState>} updates - Delvis oppdatering av state
 */
export function updateState(updates) {
  // Oppdater state
  // Trigger event eller callback hvis n√∏dvendig
}

/**
 * Henter lagret progresjon fra localStorage
 * @returns {Object<string, number>} Kart med path ‚Üí steg-indeks
 */
export function loadProgress() {
  // Les fra localStorage
  // Returner objekt eller tomt objekt hvis ikke funnet
}

/**
 * Lagrer progresjon til localStorage
 * @param {Object<string, number>} progressMap - Kart med path ‚Üí steg-indeks
 */
export function saveProgress(progressMap) {
  // Lagre til localStorage
}

/**
 * Henter siste steg for en path
 * @param {string} path - Prosjektpath
 * @returns {number} Steg-indeks (0 hvis ikke funnet)
 */
export function getLastStepFor(path) {
  // Hent fra localStorage
  // Returner 0 hvis ikke funnet
}

/**
 * Setter steg for en path
 * @param {string} path - Prosjektpath
 * @param {number} stepIndex - Steg-indeks
 */
export function setStepFor(path, stepIndex) {
  // Hent eksisterende progresjon
  // Oppdater for denne path
  // Lagre tilbake til localStorage
}
```

**Eksempel p√• state.js struktur**:

```javascript
const STORAGE_KEY = 'legoInstructions.progress';

// Modul-global state
let appState = {
  currentPath: null,
  currentStepIndex: 0,
  currentProjectMeta: null
};

export function getState() {
  return { ...appState }; // Returner kopi
}

export function updateState(updates) {
  appState = { ...appState, ...updates };
  return getState();
}

export function loadProgress() {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch (e) {
    console.error('Kunne ikke lese progresjon fra localStorage:', e);
    return {};
  }
}
```

### data-loader.js

**Rolle**: Datahenting fra JSON-filer

**Eksporterte funksjoner**:

```javascript
/**
 * ProjectMeta struktur (fra meta.json)
 * @typedef {Object} ProjectMeta
 * @property {string} id
 * @property {string} name
 * @property {string} coverImage
 * @property {string[]} steps
 * @property {Array<{id: string, name: string, path: string}>} children
 */

/**
 * Henter meta.json for et prosjekt/underprosjekt
 * @param {string} path - Prosjektpath (f.eks. "project1" eller "project1/sub-a")
 * @returns {Promise<ProjectMeta>} Prosjektmetadata
 */
export async function loadProjectMeta(path) {
  // Bygg URL: /projects/{path}/meta.json
  // Fetch og parse JSON
  // Returner ProjectMeta
}

/**
 * Henter projects.json
 * @returns {Promise<Array<{id: string, name: string, path: string}>>} Liste over prosjekter
 */
export async function loadProjects() {
  // Fetch /projects.json
  // Parse JSON
  // Returner array
}

/**
 * Bygger URL til et bilde
 * @param {string} path - Prosjektpath
 * @param {string} imageName - Filnavn p√• bildet
 * @returns {string} Full URL til bildet
 */
export function getImageUrl(path, imageName) {
  // Returner /projects/{path}/{imageName}
}

/**
 * Bygger URL til en lydfil (for steg-hjelp)
 * @param {string} path - Prosjektpath
 * @param {string} audioName - Filnavn p√• lydfil (kan ligge i /audio/)
 * @returns {string} Full URL til lydfilen
 */
export function getAudioUrl(path, audioName) {
  // Returner /projects/{path}/{audioName}
}

/**
 * Trekker ut steg-nummer fra filnavn for sortering
 * @param {string} filename - Filnavn (f.eks. "1_1x.png", "174_1x.png")
 * @returns {number|null} Steg-nummer eller null hvis ikke funnet
 */
export function extractStepNumber(filename) {
  const match = filename.match(/^(\d+)/);
  return match ? parseInt(match[1], 10) : null;
}
```

**Eksempel p√• loadProjectMeta()**:

```javascript
const BASE_URL = '/projects/';

export async function loadProjectMeta(path) {
  const url = `${BASE_URL}${path}/meta.json`;
  
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error(`Kunne ikke laste meta.json for ${path}:`, error);
    throw error;
  }
}

export function getImageUrl(path, imageName) {
  return `${BASE_URL}${path}/${imageName}`;
}

export function getAudioUrl(path, audioName) {
  return `${BASE_URL}${path}/${audioName}`;
}

export function extractStepNumber(filename) {
  const match = filename.match(/^(\d+)/);
  return match ? parseInt(match[1], 10) : null;
}
```

### view-project-grid.js

**Rolle**: Prosjektgalleri-view

- **Onboarding**: Ved f√∏rste bes√∏k skal viewet kunne tegne et lett gjennomskinnelig overlay (maskot/piler) som peker p√• f√∏rste tile med tekstfri ‚Äútrykk her‚Äù-indikasjon. Overlegget forsvinner straks barnet trykker, og en flaggverdi lagres i localStorage slik at overlayet ikke vises hver gang.
- **Underprosjekter inline**: Hvis et prosjekt har `children` og ‚Äúbarnemodus‚Äù-flagget (lagret i state/localStorage) er aktivt, kan viewet vise child-tiles direkte under hovedtile i stedet for √• navigere opp/ned. Klikk p√• child kaller fortsatt `onProjectClick` med full path.

**Eksporterte funksjoner**:

```javascript
/**
 * Renderer prosjektgalleri
 * @param {Array<{id: string, name: string, path: string}>} projects - Liste over prosjekter
 * @param {function(string): void} onProjectClick - Callback n√•r prosjekt klikkes (tar path)
 * @returns {HTMLElement} Container-element med galleri
 * 
 * Viktig: View gj√∏r IKKE direkte state/URL-oppdateringer. Den kaller onProjectClick callback
 * som sendes fra main.js, og main.js h√•ndterer state/URL-oppdateringer.
 */
export function renderProjectGrid(projects, onProjectClick) {
  // Opprett container
  // For hvert prosjekt: opprett tile med cover-bilde og navn
  // Legg til event listeners som kaller onProjectClick callback
  // Returner container
}
```

**Eksempel p√• renderProjectGrid()**:

```javascript
import { getImageUrl } from './data-loader.js';

export function renderProjectGrid(projects, onProjectClick) {
  const container = document.createElement('div');
  container.className = 'project-grid';
  
  // Filtrer bort skjulte prosjekter
  const visibleProjects = projects.filter(project => !project.hidden);
  
  visibleProjects.forEach(project => {
    const tile = document.createElement('div');
    tile.className = 'project-tile';
    tile.setAttribute('data-path', project.path);
    
    // Cover-bilde
    const img = document.createElement('img');
    img.className = 'project-tile__image';
    img.src = getImageUrl(project.path, 'cover.png');
    img.alt = project.name;
    img.onerror = () => {
      // Fallback til f√∏rste bilde hvis cover.png ikke finnes
      img.src = getImageUrl(project.path, '1_1x.png');
    };
    
    // Navn
    const name = document.createElement('div');
    name.className = 'project-tile__name';
    name.textContent = project.name;
    
    tile.appendChild(img);
    tile.appendChild(name);
    
    // Event listener
    tile.addEventListener('click', () => {
      onProjectClick(project.path);
    });
    
    container.appendChild(tile);
  });
  
  return container;
}
```

### view-viewer.js

**Rolle**: Instruksjonsviewer-view

- **Lyd/haptikk**:
  - Eksponer et h√∏yttaler-ikon for √• skru av/p√• korte navigasjonslyder (lagres i localStorage).
  - Alle piltaster/knapper kan trigge `callbacks.onFeedback?.('next')`/`('prev')` slik at main.js kan spille lyd eller trigge haptikk p√• st√∏ttede enheter.
  - Hvis prosjektene leverer egne lydhint (f.eks. `meta.audioSteps`), vis en knapp i header/bunn som spiller av hjelpetekst.
- **Loading-indikator**: Mens nytt bilde lastes skal `.viewer__main` vise en LEGO-kloss-/spinner-animajson, og knapper deaktiveres til bildet er klart.
- **Fullf√∏ringsbel√∏nning**: N√•r `currentStepIndex === steps.length - 1` og barnet g√•r videre, vis en gratulasjonsstate (konfetti-animajson + badge) og kall `callbacks.onProjectCompleted?.(state.currentPath)` slik at hovedlogikk kan markere prosjektet som ferdig.
- **Underprosjektfallback**: Dersom et prosjekt mangler `steps` men har `children`, renderer viewer en child-liste med samme ikonografi som galleriet i stedet for en tom melding.

- **Layoutkrav**:
  - `.viewer__main` skal fylle all ledig h√∏yde (`flex: 1`) og la bildet skaleres med `object-fit: contain` slik at det alltid er maks mulig st√∏rrelse uten scroll.
  - Standard-zoom i nettleser skal fungere (ikke deaktiver `pointer-events` eller `user-select` p√• bildet). Eventuell fremtidig custom zoom skjer via `transform: scale()` direkte p√• IMG.
  - Navigasjonsfeltet (`.viewer__bottom`) skal ligge helt nederst, bruke fleksibel grid/flex og inneholde store tap-targets for barn (sikte p√• ~64px h√∏yde for knapper).
  - Neste/forrige er prim√¶re kontroller; progressbaren er sekund√¶r og m√• h√•ndtere b√•de tap og drag, men UI skal ikke kreve presis drag for bruk.
  - Stegindikator b√∏r bruke tallformat (`3/10`) og/eller ikoner i stedet for tekst (‚ÄúSteg 3 av 10‚Äù) slik at m√•lgruppen (5‚Äì7 √•r) forst√•r den uten √• lese.
  - Opp/hjem-knapp representeres som ikon (hus/pil opp) og plasseres konsekvent (typisk √∏verst til venstre) slik at barna kjenner den igjen.

**Eksporterte funksjoner**:

```javascript
/**
 * Renderer instruksjonsviewer
 * @param {AppState} state - N√•v√¶rende applikasjonsstate
 * @param {Object} callbacks - Callback-funksjoner fra main.js
 * @param {function(): void} callbacks.onPrevStep - Kalles n√•r forrige steg klikkes
 * @param {function(): void} callbacks.onNextStep - Kalles n√•r neste steg klikkes
 * @param {function(number): void} callbacks.onStepChange - Kalles n√•r steg endres (tar stepIndex)
 * @param {function(): void} callbacks.onGoUp - Kalles n√•r "Opp"-knapp klikkes
 * @returns {HTMLElement} Container-element med viewer
 * 
 * Viktig: View gj√∏r IKKE direkte state/URL-oppdateringer. Den kaller callbacks som sendes
 * fra main.js, og main.js eier all state/URL-manipulasjon. Hvis steps-array er tomt,
 * vis "Ingen steg tilgjengelig" og deaktiver navigasjonskontroller.
 * Filtrer bort children med hidden: true n√•r children-liste vises.
 */
export function renderViewer(state, callbacks) {
  // H√•ndter tom steps-array: vis melding og deaktiver kontroller
  // Filtrer bort skjulte children: const visibleChildren = (state.currentProjectMeta?.children || []).filter(c => !c.hidden)
  // Opprett container med header, image container og bottom bar
  // Vis n√•v√¶rende bilde (hvis steps ikke er tom) eller children-liste (hvis steps er tom)
  // Legg til kontroller (piler, progresjonslinje, opp-knapp)
  // Legg til event listeners som kaller callbacks
  // Returner container
}
```

**Eksempel p√• renderViewer() struktur**:

```javascript
import { getImageUrl } from './data-loader.js';

export function renderViewer(state, callbacks) {
  const container = document.createElement('div');
  container.className = 'viewer';
  
  // Header (valgfritt)
  const header = document.createElement('div');
  header.className = 'viewer__header';
  header.textContent = state.currentProjectMeta?.name || '';
  
  // Image container
  const imageContainer = document.createElement('div');
  imageContainer.className = 'viewer__main';
  
  // H√•ndter tom steps-array
  const steps = state.currentProjectMeta?.steps || [];
  if (steps.length === 0) {
    const message = document.createElement('div');
    message.className = 'viewer__empty-message';
    message.textContent = 'Ingen steg tilgjengelig';
    imageContainer.appendChild(message);
  } else {
    // Bilde-rendering: Bildet skal fylle tilgjengelig plass innenfor viewport
    // - Container (.viewer__main) bruker flex: 1 for √• fylle resten av h√∏yden
    // - Bottom bar har fast h√∏yde, s√• hovedbildet f√•r all tilgjengelig plass
    // - Bildet skal v√¶re zoombart via standard nettleser-mekanismer (Ctrl/Cmd +, Ctrl/Cmd -)
    // - IKKE bruk pointer-events: none p√• bildet (blokkerer browser zoom)
    // - Hvis custom zoom skal implementeres senere: bruk transform: scale() p√• bildet,
    //   ikke endre container-st√∏rrelse (behold flex-layout for responsivitet)
    const img = document.createElement('img');
    const currentStep = steps[state.currentStepIndex];
    if (currentStep) {
      img.src = getImageUrl(state.currentPath, currentStep);
      img.alt = `Steg ${state.currentStepIndex + 1}`;
    }
    imageContainer.appendChild(img);
  }
  
  // Bottom bar: Har fast h√∏yde slik at hovedbildet alltid kan bruke resten av h√∏yden
  const bottomBar = document.createElement('div');
  bottomBar.className = 'viewer__bottom';
  
  // Opp-knapp
  const upButton = document.createElement('button');
  upButton.className = 'viewer__button';
  upButton.textContent = 'Opp';
  upButton.addEventListener('click', callbacks.onGoUp);
  
  // Pil-knapper (deaktiver hvis ingen steg)
  const prevButton = document.createElement('button');
  prevButton.className = 'viewer__button';
  prevButton.textContent = '‚Üê';
  prevButton.disabled = steps.length === 0 || state.currentStepIndex === 0;
  if (steps.length > 0) {
    prevButton.addEventListener('click', callbacks.onPrevStep);
  }
  
  const nextButton = document.createElement('button');
  nextButton.className = 'viewer__button';
  nextButton.textContent = '‚Üí';
  nextButton.disabled = steps.length === 0 || state.currentStepIndex === (steps.length - 1);
  if (steps.length > 0) {
    nextButton.addEventListener('click', callbacks.onNextStep);
  }
  
  // Progresjonslinje (skjul hvis ingen steg)
  const progressBar = document.createElement('input');
  progressBar.className = 'viewer__progress';
  progressBar.type = 'range';
  progressBar.min = 0;
  progressBar.max = Math.max(0, steps.length - 1);
  progressBar.value = state.currentStepIndex;
  progressBar.disabled = steps.length === 0;
  if (steps.length > 0) {
    progressBar.addEventListener('input', (e) => {
      callbacks.onStepChange(parseInt(e.target.value, 10));
    });
  }
  
  // Steg-indikator
  const stepIndicator = document.createElement('div');
  stepIndicator.className = 'viewer__step-indicator';
  stepIndicator.textContent = steps.length === 0 
    ? 'Ingen steg tilgjengelig'
    : `Steg ${state.currentStepIndex + 1} av ${steps.length}`;
  
  bottomBar.appendChild(upButton);
  bottomBar.appendChild(prevButton);
  bottomBar.appendChild(progressBar);
  bottomBar.appendChild(nextButton);
  bottomBar.appendChild(stepIndicator);
  
  container.appendChild(header);
  container.appendChild(imageContainer);
  container.appendChild(bottomBar);
  
  return container;
}
```

## Error handling

### Prinsipper

1. **Graceful degradation**: Applikasjonen skal ikke krasje ved feil
2. **Brukervennlige meldinger**: Vis forst√•elige feilmeldinger
3. **Logging**: Log feil til konsollen for debugging

### Error handling-patterns

```javascript
// Ved datahenting
try {
  const meta = await loadProjectMeta(path);
  // Bruk meta
} catch (error) {
  console.error('Kunne ikke laste prosjekt:', error);
  // Vis feilmelding til bruker
  showError('Kunne ikke laste prosjekt. Pr√∏v igjen senere.');
}

// Ved bildevisning
img.onerror = () => {
  console.error('Kunne ikke laste bilde:', img.src);
  // Vis fallback eller feilmelding
  img.src = '/assets/placeholder.png';
};

// Ved localStorage
try {
  localStorage.setItem(key, value);
} catch (e) {
  console.warn('Kunne ikke lagre til localStorage:', e);
  // Fortsett uten lagring
}
```

## Event handling

### Pattern for event listeners

```javascript
// Legg til event listener
element.addEventListener('click', handleClick);

// Fjern event listener (hvis n√∏dvendig)
element.removeEventListener('click', handleClick);

// Event delegation (hvis dynamisk innhold)
container.addEventListener('click', (e) => {
  if (e.target.matches('.project-tile')) {
    handleProjectClick(e.target);
  }
});
```

### Callback-pattern

```javascript
import { getState, updateState } from './state.js';
import { updateHash } from './router.js';

// Definer callback-interface
const callbacks = {
  onProjectClick: (path) => {
    updateState({ currentPath: path });
    updateHash({ type: 'project', path });
  },
  onStepChange: (stepIndex) => {
    updateState({ currentStepIndex: stepIndex });
    const { currentPath } = getState();
    updateHash({ 
      type: 'project', 
      path: currentPath,
      stepIndex 
    });
  }
};

// Pass til view
const view = renderViewer(getState(), callbacks);
```

## DOM-manipulering

### Pattern for rendering

```javascript
// Opprett element
const element = document.createElement('div');
element.className = 'my-class';

// Sett attributter
element.setAttribute('data-id', id);
element.id = 'unique-id';

// Legg til innhold
element.textContent = 'Tekst';
element.innerHTML = '<span>HTML</span>'; // Bruk forsiktig

// Legg til child
parent.appendChild(child);

// Erstatt innhold
container.innerHTML = ''; // T√∏m
container.appendChild(newContent); // Legg til nytt
```

### Oppdatering av eksisterende views

**Merk**: F√∏lgende er valgfrie patterns som kan brukes ved behov, men er ikke krav i f√∏rste versjon.

```javascript
import { getImageUrl } from './data-loader.js';

// I stedet for √• re-rendere hele view, oppdater kun det som endres
function updateViewerImage(state) {
  const img = document.querySelector('.viewer__main img');
  const step = state.currentProjectMeta.steps[state.currentStepIndex];
  img.src = getImageUrl(state.currentPath, step);
}

function updateProgressBar(state) {
  const progressBar = document.querySelector('.viewer__bottom input[type="range"]');
  progressBar.value = state.currentStepIndex;
  progressBar.max = state.currentProjectMeta.steps.length - 1;
}
```

## Async/await patterns

```javascript
// H√•ndter async operasjoner
async function loadAndRender(path) {
  try {
    const meta = await loadProjectMeta(path);
    const state = {
      currentPath: path,
      currentStepIndex: 0,
      currentProjectMeta: meta
    };
    renderViewer(state, callbacks);
  } catch (error) {
    console.error('Feil ved lasting:', error);
    showError('Kunne ikke laste prosjekt');
  }
}

// Parallel lasting (valgfri pattern, ikke krav i f√∏rste versjon)
async function loadMultipleProjects(paths) {
  const promises = paths.map(path => loadProjectMeta(path));
  const results = await Promise.all(promises);
  return results;
}

## Testing under implementering

### Manuell testing-checklist

For hver funksjon du implementerer:

1. **Test i nettleseren** (se ROADMAP.md for detaljer)
2. **Sjekk konsollen** for feil
3. **Test edge cases**:
   - Tomme arrays
   - Manglende filer
   - Ugyldig data
   - localStorage deaktivert
4. **Test p√• ulike skjermst√∏rrelser**
5. **Test navigasjon** mellom alle views

### Debugging-tips

```javascript
// Logging for debugging
console.log('State:', state);
console.log('Route:', route);

// Breakpoints i DevTools
debugger; // Pause her

// Sjekk localStorage
console.log('Progress:', localStorage.getItem('legoInstructions.progress'));

// Inspiser DOM
console.log('Container:', container);
```

## Beste praksis

1. **Kort og fokuserte funksjoner**: Maks 50 linjer per funksjon
2. **Dokumenter kompleks logikk**: Kommenter hvorfor, ikke hva
3. **Bruk beskrivende navn**: `loadProjectMeta` er bedre enn `load`
4. **H√•ndter feil gracefully**: Applikasjonen skal ikke krasje
5. **Test inkrementelt**: Test hver del f√∏r du g√•r videre
6. **Hold moduler l√∏st koblet**: Moduler skal ikke v√¶re for avhengige av hverandre



--------------------------------------------------
File End
--------------------------------------------------


docs\README.md
File type: .md
# LEGO Instruksjonsvisning

Et enkelt, statisk nettsted for √• vise LEGO-byggeinstruksjoner som PNG-bilder med strukturert navigasjon.

## Prosjektoversikt

Dette prosjektet lar deg organisere og vise LEGO-instruksjoner i et hierarkisk system:
- **Prosjekt** ‚Üí (valgfritt) **Underprosjekter** ‚Üí **Steg-bilder**

Dette prosjektet lar deg bla i instruksjonssteg som p√• en ekte LEGO-byggebok ‚Äî men med dine egne modeller.

Nettsiden er bygget med ren HTML, CSS og JavaScript, og kan hostes hvor som helst som st√∏tter statisk hosting.

## Funksjoner

### F√∏rste versjon

- **Prosjektgalleri**: Oversikt over alle tilgjengelige prosjekter med cover-bilder
- **Hierarkisk navigasjon**: St√∏tte for prosjekter med underprosjekter
- **Stegvis visning**: Naviger mellom instruksjonsbilder med pil-knapper
- **Progresjonslinje**: Vis hvor langt du har kommet, klikk/drag for √• hoppe til spesifikt steg
- **Opp-navigasjon**: Knapp for √• g√• "ett hakk opp" i hierarkiet
- **Posisjonslagring**: Automatisk lagring av hvor du var (prosjekt + steg) i localStorage
- **Responsivt design**: Fungerer p√• mobil, nettbrett og PC
- **Ingen scroll**: Instruksjonsbildet tilpasses skjermen uten scrolling

### Planlagte funksjoner

- QR-kode-generering for √• dele spesifikke steg
- Loading-indikatorer og preloading av bilder
- Caching-strategier for bedre ytelse

## Brukeropplevelse for barn 5‚Äì7 √•r

Prosjektet er prim√¶rt laget for barn som enn√• ikke kan lese flytende. UI-et skal derfor f√∏lge disse prinsippene:

- **Ikoner og tall fremfor tekst**: Bruk hus/pil-symboler, store neste/forrige-ikoner og tallformat (`3/10`) i stedet for strenger som ‚ÄúSteg 3 av 10‚Äù.
- **Store trykkflater**: Alle prim√¶rknapper skal minst v√¶re 44x44px ‚Äì helst rundt 64px (‚âà2 cm) ‚Äì med god avstand (`var(--spacing-md)`+) mellom elementene slik at sm√• fingre treffer riktig.
- **Tydelig feedback**: Navigasjonsknapper skal animere/lyses opp ved trykk, og applikasjonen kan spille korte lyder eller vise sm√• animasjoner (f.eks. konfetti ved fullf√∏ring) for √• gi mestringsf√∏lelse.
- **Hierarki uten tekst**: Opp/hjem-knappen skal v√¶re et ikon og ligge p√• samme sted p√• alle skjermer. Underprosjekter kan presenteres som egne tiles med klare bilder slik at barna skj√∏nner hva som skjer uten beskrivelse.
- **Enkle interaksjoner**: Pilene er prim√¶rnavigasjon. Progresjonslinjen er sekund√¶r (tapping fremfor presis dragging). Swipe-gestures p√• bildet kan implementeres som ekstra hjelp.
- **Tilgjengelighet**: Alle bilder skal ha `alt`-tekst myntet p√• foreldre, og fargevalg skal ha god kontrast slik at knappene er tydelige under alle lysforhold.
- **Onboarding**: F√∏rste gang appen √•pnes, vis en visuell overlay (maskot/piler) som peker p√• det f√∏rste prosjektet og forsvinner idet barnet trykker. Lagre i localStorage at onboarding er gjennomf√∏rt.
- **Underprosjekter inline**: Prosjekter med `children` kan vises i samme skjerm som galleriet (flatt layout) slik at barnet slipper √• navigere ‚Äúopp ett niv√•‚Äù. Viewer skal kun √•pnes n√•r man velger et konkret steg eller child.
- **Lyd og haptikk**: En h√∏yttaler-knapp lar voksne skru av/p√• korte ‚Äúklikk‚Äù-lyder. P√• enheter som st√∏tter det kan knappetrykk trigge haptisk feedback. Eventuelle lydinstruksjoner per steg kan legges i `projects/<path>/audio/` og refereres fra `meta.json`.
- **Loading og bel√∏nning**: Mens bilder lastes skal en LEGO-inspirert spinner vises, og n√•r siste steg fullf√∏res vises en enkel gratulasjonsanimasjon (konfetti/badge) samt at progresjonen markeres som ferdig.
- **Barnemodus**: UI-et kan styres av en `childMode`-innstilling (lagret i localStorage eller konfigurasjonsfil). N√•r den er aktiv vil galleri/child-visning f√∏lge flat struktur, onboarding-overlegg aktiveres, og tekst erstattes med ikoner.

## Teknisk oversikt

- **Teknologi**: Ren HTML + CSS + JavaScript (ingen build tools eller dependencies)
- **Hosting**: Statisk hosting (designet for GitHub Pages)
- **Routing**: Hash-basert routing (`#/p/project1?step=3`)
- **State management**: localStorage for progresjonslagring
- **Dataformat**: JSON-filer (`meta.json` og `projects.json`)

## Bildstruktur og navngivning

### Bildnavn

Bilder skal navngis med formatet: `[nummer]*.png`

- Nummeret m√• komme f√∏rst i filnavnet (dette er formatet som Bricklink Studio 2.0 genererer bildene p√•)
- Nummeret m√• st√• f√∏rst fordi filene sorteres automatisk basert p√• nummeret. Alt etter nummeret ignoreres ved sortering
- Etter nummeret kan det v√¶re hva som helst (f.eks. `_1x`, `_2x`, `_cover`, etc.)
- Filen m√• ende med `.png`

**Eksempler:**
- `1_1x.png`
- `174_1x.png`
- `1_2x.png`
- `1_cover.png`

### Cover-bilde

Hver prosjektmappe kan ha et spesielt `cover.png`-bilde som brukes som cover i prosjektgalleriet.

- Hvis `cover.png` finnes, brukes den som cover-bilde
- Hvis `cover.png` ikke finnes, brukes det f√∏rste bildet (laveste nummer) som cover

### Rekkef√∏lge og sortering

Bildene sorteres automatisk basert p√• nummeret i filnavnet. S√∏rg for at nummerene er konsistente for riktig rekkef√∏lge.

**Hvordan sortering fungerer:**
- Systemet leser kun nummeret i starten av filnavnet
- Alt etter nummeret (som `_1x`, `_cover`, `_2x`, etc.) ignoreres ved sortering
- Dette betyr at `1_1x.png`, `1_cover.png` og `1_2x.png` alle vil sorteres som nummer 1
- For √• sikre riktig rekkef√∏lge, bruk unike numre for hvert steg

## Filstruktur

```
/lego-instruksjoner/
  index.html
  /assets/
    /css/
      main.css
    /js/
      main.js
      router.js
      state.js
      view-project-grid.js
      view-viewer.js
      data-loader.js
  /projects/
    project1/
      meta.json
      cover.png (valgfritt)
      1_1x.png
      2_1x.png
      ...
      subproject-a/
        meta.json
        cover.png (valgfritt)
        1_1x.png
        2_1x.png
        ...
    project2/
      meta.json
      ...
  projects.json
```

## Hurtigstart

### 1. Klon eller last ned prosjektet

```bash
git clone <repository-url>
cd lego-instruksjoner
```

### 2. Legg til prosjekter

Se [Hvordan legge til nye prosjekter](#hvordan-legge-til-nye-prosjekter) nedenfor.

### 3. Test lokalt

Siden dette skal hostes p√• GitHub Pages, anbefales det √• teste via en lokal webserver:

```bash
# Python 3
python -m http.server 8000

# Node.js (med http-server)
npx http-server -p 8000
```

√Öpne nettleseren og g√• til `http://localhost:8000`

### 4. Deploy til GitHub Pages

1. Push koden til GitHub-repositoryet
2. G√• til Settings ‚Üí Pages i GitHub-repositoryet
3. Velg branch og mappe (vanligvis `main` og `/root`)
4. Nettsiden vil v√¶re tilgjengelig p√• `https://<username>.github.io/<repository-name>`

## Hvordan legge til nye prosjekter

**Kortversjon:**
1. Lag mappe under `/projects/`
2. Legg inn bilder med riktig navngivning
3. Lag `meta.json`-fil
4. (Valgfritt) Legg til underprosjekter
5. Oppdater `projects.json`

### Steg 1: Opprett prosjektmappe

Opprett en ny mappe under `/projects/` med et beskrivende navn:

```
/projects/mitt-prosjekt/
```

### Steg 2: Legg til bilder

Legg alle instruksjonsbildene i prosjektmappen med riktig navngivning:

```
/projects/mitt-prosjekt/
  1_1x.png
  2_1x.png
  3_1x.png
  ...
```

### Steg 3: Legg til cover-bilde (valgfritt)

Hvis du vil ha et spesielt cover-bilde, legg det til som `cover.png`:

```
/projects/mitt-prosjekt/
  cover.png
  1_1x.png
  ...
```

### Steg 4: Opprett meta.json

Opprett en `meta.json`-fil i prosjektmappen:

```json
{
  "id": "mitt-prosjekt",
  "name": "Mitt Prosjekt",
  "coverImage": "cover.png",
  "steps": [
    "1_1x.png",
    "2_1x.png",
    "3_1x.png"
  ],
  "children": []
}
```

**Forklaring:**
- `id`: Unik identifikator for prosjektet
- `name`: Visningsnavn
- `coverImage`: Navn p√• cover-bildet (eller f√∏rste bilde hvis ikke spesifisert)
- `steps`: Array med alle steg-bildene i riktig rekkef√∏lge
- `children`: Array med underprosjekter (tom hvis ingen)

### Steg 5: Legg til underprosjekter (valgfritt)

Hvis prosjektet har underprosjekter:

1. Opprett undermappe: `/projects/mitt-prosjekt/underprosjekt-a/`
2. Legg til bilder og `meta.json` i undermappen
3. Oppdater `meta.json` i hovedprosjektet:

```json
{
  "id": "mitt-prosjekt",
  "name": "Mitt Prosjekt",
  "coverImage": "cover.png",
  "steps": [
    "1_1x.png",
    "2_1x.png"
  ],
  "children": [
    {
      "id": "underprosjekt-a",
      "name": "Underprosjekt A",
      "path": "underprosjekt-a"
    }
  ]
}
```

**Forklaring av `path`:**
- `path` er navnet p√• undermappen (relativ sti)
- Hvis undermappen heter `t√•rn/`, settes `path` til `"t√•rn"`
- Dette er den relative stien fra hovedprosjektmappen til undermappen

### Steg 6: Oppdater projects.json

Legg til det nye prosjektet i `projects.json` i rotmappen:

```json
[
  {
    "id": "mitt-prosjekt",
    "name": "Mitt Prosjekt",
    "path": "mitt-prosjekt"
  },
  {
    "id": "annet-prosjekt",
    "name": "Annet Prosjekt",
    "path": "annet-prosjekt"
  }
]
```

Se [DATA_FORMAT.md](./DATA_FORMAT.md) for detaljert dokumentasjon av JSON-formatene.

## Bruk

### Navigasjon

1. **Prosjektgalleri**: Startside viser alle tilgjengelige prosjekter
2. **Velg prosjekt**: Klikk p√• et prosjekt for √• √•pne det
3. **Naviger mellom steg**: Bruk pil-knappene eller progresjonslinjen
4. **G√• tilbake**: Bruk "Opp"-knappen for √• g√• ett niv√• opp i hierarkiet
5. **G√• til prosjektgalleri**: G√• tilbake til rotniv√•et for √• velge et annet prosjekt

### URL-struktur

- Prosjektgalleri: `/#/` eller `/#`
- Prosjekt: `/#/p/project1`
- Prosjekt med steg: `/#/p/project1?step=3`
- Underprosjekt: `/#/p/project1/subproject-a`

URL-en oppdateres automatisk n√•r du navigerer, s√• du kan bookmarke spesifikke steg.

For tekniske detaljer om routing, state og modulstruktur, se [ARCHITECTURE.md](./ARCHITECTURE.md).

## St√∏ttede plattformer

Nettsiden er designet for moderne nettlesere p√•:

- **Mobil**: iOS Safari, Chrome Mobile, Samsung Internet
- **Nettbrett**: iPad, Android-tabletter
- **PC**: Chrome, Firefox, Edge, Safari (siste versjoner)

Ingen st√∏tte for eldre nettlesere (IE, etc.).

## Kjente begrensninger

F√∏lgende funksjoner er planlagt for fremtidige versjoner:

- Loading-indikatorer mens bilder lastes
- Preloading av neste bilde for raskere navigasjon
- Caching-strategier for bedre ytelse
- Tastaturnavigasjon (piltaster, escape)
- Touch gestures p√• mobil (swipe)
- Ingen offline-st√∏tte enn√• (kommer med caching-strategien)

## Dokumentasjon

- [ARCHITECTURE.md](./ARCHITECTURE.md) - Teknisk arkitektur og komponentoversikt
- [ROADMAP.md](./ROADMAP.md) - Implementasjonsplan og fremtidige funksjoner
- [DATA_FORMAT.md](./DATA_FORMAT.md) - Detaljert dokumentasjon av JSON-formater

## Skjermbilder

Skjermbilder av grensesnittet vil bli lagt til n√•r UI-en er implementert.

## Lisens

Privat prosjekt ‚Äì ingen redistribusjon.



--------------------------------------------------
File End
--------------------------------------------------


docs\ROADMAP.md
File type: .md
# Roadmap

Dette dokumentet beskriver implementasjonsplanen og fremtidige funksjoner for LEGO Instruksjonsvisning-prosjektet.

## Hvordan denne roadmapen skal brukes (for AI)

**‚ö†Ô∏è START HER**: Les [AI_GUIDE.md](./AI_GUIDE.md) f√∏rst for en oversikt over alle dokumenter og kritiske regler.

- Jobb alltid i rekkef√∏lge innenfor en fase (1.1 f√∏r 1.2, osv.), med mindre jeg eksplisitt sier noe annet.
- Etter hver oppgave: oppdater denne filen og sett `[ ]` ‚Üí `[x]` der det passer.
- Ikke hopp til Fase 2 eller 3 f√∏r alle M1/M2-kriterier er oppfylt.
- Respekter dataformater som beskrevet i [DATA_FORMAT.md](./DATA_FORMAT.md) ‚Äì ikke endre formater uten √• foresl√• det f√∏rst.
- Ved tvil: foresl√• 2‚Äì3 alternativer i en kommentar, ikke gjett.
- Se [ARCHITECTURE.md](./ARCHITECTURE.md) for arkitekturdetaljer og [IMPLEMENTATION.md](./IMPLEMENTATION.md) for kodeeksempler.

## Fase 1: Grunnleggende struktur (F√∏rste versjon)

### 1.1 Prosjektoppsett
- [ ] **1.1.1** Opprett filstruktur (index.html, assets/css/main.css, assets/js/*.js)
  - **M√•l**: Opprett alle n√∏dvendige mapper og tomme filer
- [ ] **1.1.2** Sett opp grunnleggende HTML-struktur
  - **M√•l**: Opprett index.html med grunnleggende struktur og lenker til CSS/JS
- [ ] **1.1.3** Implementer grunnleggende CSS-layout
  - **M√•l**: Grunnleggende styling og layout (se [CSS_GUIDELINES.md](./CSS_GUIDELINES.md))
  - **üåê TEST I NETTLESER**: Verifiser at siden laster og grunnleggende styling vises

### 1.2 Statiske testdata
- [ ] **1.2.1** Opprett √©n testprosjektmappe med meta.json
  - **M√•l**: Opprett mappe under /projects/ med meta.json (se [DATA_FORMAT.md](./DATA_FORMAT.md))
- [ ] **1.2.2** Legg til cover.png og noen step-bilder
  - **M√•l**: Legg til minst 3-5 testbilder med riktig navngivning
  - **Merk**: Dette gj√∏res manuelt av brukeren - AI skal ikke implementere dette steget
- [ ] **1.2.3** Opprett projects.json med testprosjektet
  - **M√•l**: Opprett projects.json i rotmappen med referanse til testprosjektet

### 1.3 Router og root-view
- [ ] **1.3.1** Implementer router.js med hash-parsing
  - **M√•l**: Funksjoner for √• parse hash og oppdatere URL (se [IMPLEMENTATION.md](./IMPLEMENTATION.md))
- [ ] **1.3.2** Implementer view-project-grid.js
  - **M√•l**: Renderer prosjektgalleri med cover-bilder og navn
  - **üåê TEST I NETTLESER**: Verifiser at prosjektgalleri vises med cover-bilder
- [ ] **1.3.3** Koble router til prosjektgalleri-view
  - **M√•l**: Router trigges ved hash-endringer og viser galleri
  - **üåê TEST I NETTLESER**: Verifiser at hash-endringer trigges og galleri vises
- [ ] **1.3.4** Test navigasjon til prosjektgalleri
  - **üåê TEST I NETTLESER**: Test at klikk p√• prosjekt navigerer til riktig URL

### 1.4 Data-loader og viewer
- [ ] **1.4.1** Implementer data-loader.js for √• hente meta.json
  - **M√•l**: Funksjoner for √• hente projects.json og meta.json med fetch
  - **üåê TEST I NETTLESER**: Sjekk i Network-tab at meta.json og projects.json lastes uten feil
- [ ] **1.4.2** Implementer view-viewer.js med enkel bildevisning
  - **M√•l**: Vise f√∏rste steg-bilde for valgt prosjekt
  - **üåê TEST I NETTLESER**: Verifiser at riktig bilde vises n√•r du g√•r direkte til /#/p/<path>
- [ ] **1.4.3** Legg til pil-knapper for neste/forrige steg
  - **M√•l**: Navigasjonsknapper som oppdaterer state og URL
  - **üåê TEST I NETTLESER**: Test at pil-knappene fungerer og bytter bilde
- [ ] **1.4.4** Test navigasjon mellom steg
  - **üåê TEST I NETTLESER**: Test at alle steg kan navigeres mellom

### 1.5 Progresjonslinje og opp-knapp
- [ ] **1.5.1** Implementer progresjonslinje (range-input eller custom)
  - **M√•l**: Range-input eller custom progress bar som viser n√•v√¶rende steg
  - **üåê TEST I NETTLESER**: Verifiser at progresjonslinje vises og kan klikkes/dragges
- [ ] **1.5.2** Legg til "Opp"-knapp for hierarkisk navigasjon
  - **M√•l**: Knapp som navigerer ett niv√• opp i hierarkiet
  - **üåê TEST I NETTLESER**: Verifiser at "Opp"-knappen vises og fungerer
- [ ] **1.5.3** Implementer logikk for √• g√• tilbake til forelder
  - **M√•l**: Beregn forelder-path og naviger dit
  - **üåê TEST I NETTLESER**: Test at "Opp"-knapp navigerer til forelder
- [ ] **1.5.4** Test hierarkisk navigasjon
  - **üåê TEST I NETTLESER**: Test full hierarkisk navigasjon (opp/ned i treet)

### 1.6 localStorage-lagring
- [ ] **1.6.1** Implementer state.js med localStorage-integrasjon
  - **M√•l**: State management med getters/setters og localStorage-synkronisering
- [ ] **1.6.2** Lagre progresjon per prosjektpath
  - **M√•l**: Automatisk lagring av steg-indeks n√•r bruker navigerer
  - **üåê TEST I NETTLESER**: Verifiser i DevTools Application-tab at data lagres i localStorage
- [ ] **1.6.3** Les lagret progresjon ved applikasjonsstart
  - **M√•l**: Hent lagret progresjon og bruk ved navigering til prosjekt
  - **üåê TEST I NETTLESER**: Test at lagret progresjon leses ved reload av siden
- [ ] **1.6.4** Test at posisjon lagres og gjenopptas
  - **üåê TEST I NETTLESER**: Naviger til steg 5, reload siden, verifiser at steg 5 vises

### 1.7 CSS og responsivt design
- [ ] **1.7.1** Implementer "ingen scroll" p√• instruksjonsvisning
  - **M√•l**: Image container skal fylle plass uten scroll (se [CSS_GUIDELINES.md](./CSS_GUIDELINES.md))
  - **üåê TEST I NETTLESER**: Verifiser at ingen scroll-bars vises p√• image container
- [ ] **1.7.2** Tilpass bildet til skjermen (object-fit: contain)
  - **M√•l**: Bildet skal tilpasses skjermen uten √• kuttes
  - **üåê TEST I NETTLESER**: Verifiser at bildet tilpasses skjermen uten √• kuttes
- [ ] **1.7.3** Responsivt design for mobil, nettbrett og PC
  - **M√•l**: Mobile-first CSS med media queries
  - **üåê TEST I NETTLESER**: Test responsivt design i DevTools device mode
- [ ] **1.7.4** Test p√• ulike skjermst√∏rrelser
  - **üåê TEST I NETTLESER**: Test p√• mobil (375px), nettbrett (768px) og desktop (1920px)

### 1.8 Filtrering av skjulte prosjekter
- [ ] **1.8.1** Implementer filtrering av skjulte prosjekter i prosjektgalleri
  - **M√•l**: Filtrer bort prosjekter med `hidden: true` fra prosjektgalleri (se [DATA_FORMAT.md](./DATA_FORMAT.md))
  - **üåê TEST I NETTLESER**: Legg til prosjekt med `hidden: true` i projects.json, verifiser at det ikke vises i galleri
- [ ] **1.8.2** Implementer filtrering av skjulte children i viewer
  - **M√•l**: Filtrer bort children med `hidden: true` n√•r children-liste vises (se [DATA_FORMAT.md](./DATA_FORMAT.md))
  - **üåê TEST I NETTLESER**: Legg til child med `hidden: true` i meta.json, verifiser at det ikke vises i children-liste
- [ ] **1.8.3** Test at skjulte prosjekter fortsatt er tilgjengelige via direkte URL
  - **üåê TEST I NETTLESER**: Naviger direkte til skjult prosjekt via URL, verifiser at det vises

### 1.9 Generalisering
- [ ] **1.9.1** Test med flere prosjekter
  - **üåê TEST I NETTLESER**: Legg til 2-3 prosjekter og verifiser at alle synlige vises i galleri
- [ ] **1.9.2** Test med underprosjekter
  - **üåê TEST I NETTLESER**: Test prosjekt med underprosjekter, verifiser navigasjon
- [ ] **1.9.3** Verifiser at hierarkisk navigasjon fungerer
  - **üåê TEST I NETTLESER**: Test full navigasjonsflyt: galleri ‚Üí prosjekt ‚Üí underprosjekt ‚Üí steg ‚Üí tilbake
- [ ] **1.9.4** End-to-end testing
  - **üåê TEST I NETTLESER**: Gjennomf√∏re komplett brukeropplevelse fra start til slutt

## Fase 2: Forbedringer og optimalisering

### 2.1 Brukeropplevelse
- [ ] **2.1.1** Loading-indikatorer mens bilder lastes
  - **M√•l**: Vis spinner eller loading-indikator mens bilder lastes
  - **üåê TEST I NETTLESER**: Verifiser at loading-indikator vises mens bilder lastes
- [ ] **2.1.2** Preloading av neste bilde for raskere navigasjon
  - **M√•l**: Last neste bilde i bakgrunnen for raskere navigasjon
  - **üåê TEST I NETTLESER**: Verifiser i Network-tab at neste bilde lastes i forkant
- [ ] **2.1.3** Feilh√•ndtering for manglende bilder/filer
  - **M√•l**: Graceful error handling med fallback eller feilmeldinger
  - **üåê TEST I NETTLESER**: Test med manglende bilder/filer, verifiser feilh√•ndtering
- [ ] **2.1.4** Forbedret feilmeldinger
  - **M√•l**: Brukervennlige feilmeldinger i stedet for tekniske
  - **üåê TEST I NETTLESER**: Verifiser at brukervennlige feilmeldinger vises

### 2.2 Navigasjon
- [ ] **2.2.1** Tastaturnavigasjon (piltaster for neste/forrige)
  - **M√•l**: Arrow keys for √• navigere mellom steg
  - **üåê TEST I NETTLESER**: Test at piltaster fungerer for neste/forrige steg
- [ ] **2.2.2** Escape-tast for √• g√• tilbake
  - **M√•l**: Escape-tast navigerer ett niv√• opp eller tilbake
  - **üåê TEST I NETTLESER**: Test at Escape-tast navigerer tilbake
- [ ] **2.2.3** Touch gestures p√• mobil (swipe venstre/h√∏yre)
  - **M√•l**: Swipe-gestures for navigasjon p√• touch-enheter
  - **üåê TEST I NETTLESER**: Test swipe-gestures p√• mobil eller i DevTools device mode
- [ ] **2.2.4** Keyboard shortcuts-dokumentasjon
  - **M√•l**: Dokumenter alle keyboard shortcuts

### 2.3 Ytelse
- [ ] **2.3.1** Caching-strategier for bilder
  - **M√•l**: Implementer caching for raskere lasting av bilder
  - **üåê TEST I NETTLESER**: Verifiser i Network-tab at bilder caches og lastes fra cache
- [ ] **2.3.2** Lazy loading av bilder
  - **M√•l**: Last bilder kun n√•r de trengs, ikke alle p√• en gang
  - **üåê TEST I NETTLESER**: Verifiser at bilder lastes kun n√•r de trengs
- [ ] **2.3.3** Optimalisering av bildevisning
  - **M√•l**: Optimaliser bildevisning for bedre ytelse
  - **üåê TEST I NETTLESER**: Test ytelse med Performance-tab i DevTools
- [ ] **2.3.4** Grunnleggende caching-strategier (uten Service Worker)
  - **M√•l**: Browser-caching og localStorage for bilder/metadata
  - **üåê TEST I NETTLESER**: Verifiser at browser cacher ressurser

### 2.4 Progresjonsvisning
- [ ] **2.4.1** Vis progresjonsindikator i prosjektgalleri
  - **M√•l**: Vis hvor langt brukeren har kommet i hvert prosjekt i galleriet
  - **üåê TEST I NETTLESER**: Verifiser at progresjonsindikator vises i prosjektgalleri
- [ ] **2.4.2** Vis hvor langt man har kommet per prosjekt
  - **M√•l**: Vis progresjon (f.eks. "3/10 steg") for hvert prosjekt
  - **üåê TEST I NETTLESER**: Verifiser at korrekt progresjon vises for hvert prosjekt
- [ ] **2.4.3** Mulighet for √• nullstille progresjon
  - **M√•l**: Knapp eller funksjonalitet for √• nullstille lagret progresjon
  - **üåê TEST I NETTLESER**: Test at nullstilling fungerer og oppdaterer visning

### 2.5 Barnevennlig UI
- [ ] **2.5.1** Ikonbasert navigasjon
  - **M√•l**: Erstatt/suppler tekst med ikoner (hus, piler, stjerner) i viewer og galleri
  - **üåê TEST I NETTLESER**: Verifiser at alle prim√¶re handlinger kan utf√∏res uten √• lese tekst
- [ ] **2.5.2** Store trykkflater og spacing
  - **M√•l**: √òk st√∏rrelse p√• knapper og klikksoner (‚â•64px) og legg til tilstrekkelig spacing
  - **üåê TEST I NETTLESER**: Test p√• mobil/nettbrett at knapper er lette √• treffe
- [ ] **2.5.3** Visuell/lyd feedback
  - **M√•l**: Legg til mikroanimasjoner og valgfri lyd n√•r barnet navigerer, samt en enkel bel√∏nning ved fullf√∏rt prosjekt
  - **üåê TEST I NETTLESER**: Verifiser at feedback trigges ved interaksjon og kan skrus av/p√•
- [ ] **2.5.4** Intro/hjelp for barn
  - **M√•l**: Implementer en kort visuell onboarding (f.eks. maskot eller highlight) som viser hvordan man blar
  - **üåê TEST I NETTLESER**: Test at introen kan avbrytes og kun vises ved behov

### 2.6 Tilgjengelighet og input
- [ ] **2.6.1** Swipe-gestures i viewer
  - **M√•l**: Swipe venstre/h√∏yre p√• bildet gj√∏r samme som pilene
  - **üåê TEST I NETTLESER**: Test p√• touch-enheter
- [ ] **2.6.2** Alt-tekst og kontrastsjekk
  - **M√•l**: S√∏rg for alt-tekst p√• bilder og dokumenter kontrastkrav i CSS_guidelines
  - **üåê TEST I NETTLESER**: Kj√∏r Lighthouse/axe for tilgjengelighetsvarsler

### 2.7 Loading, feilh√•ndtering og bel√∏nning
- [ ] **2.7.1** LEGO-inspirert loading-indikator
  - **M√•l**: Vise animert kloss/spinner mens bilder lastes, deaktivere kontroller inntil bildet er klart
  - **üåê TEST I NETTLESER**: Kunstig treghet (DevTools) for √• verifisere at indikator vises
- [ ] **2.7.2** Brukervennlige feilmeldinger
  - **M√•l**: Vennlig melding n√•r bilde/meta mangler (‚ÄúOi! Fant ikke bildet ‚Äì sp√∏r en voksen‚Äù)
  - **üåê TEST I NETTLESER**: Simuler 404 og sjekk at melding vises
- [ ] **2.7.3** Fullf√∏ringsbel√∏nning
  - **M√•l**: Konfetti/badge + state-markering n√•r prosjekt er ferdig
  - **üåê TEST I NETTLESER**: Naviger til siste steg og se at bel√∏nning trigges, og at det kan trigges kun √©n gang per prosjekt

### 2.8 Lyd, haptikk og voiceover
- [ ] **2.8.1** Navigasjonslyd/haptikk
  - **M√•l**: Korte ‚Äúklikk‚Äù-lyder og haptikk p√• pil/opp-knapp (kan skrus av/p√•)
  - **üåê TEST I NETTLESER**: Verifiser toggle + fallback n√•r API ikke st√∏ttes
- [ ] **2.8.2** Steg-vis lydhint
  - **M√•l**: St√∏tte `audioSteps` fra meta.json og knapp for √• spille av lyd per steg
  - **üåê TEST I NETTLESER**: Test med sample-lyd, verifiser at feil h√•ndteres
- [ ] **2.8.3** Onboarding-stemme/figur
  - **M√•l**: Maskot/overlay som visuelt (og evt. auditivt) viser hvordan man starter
  - **üåê TEST I NETTLESER**: S√∏rg for at overlay vises kun f√∏rste gang og kan avbrytes

## Fase 3: Avanserte funksjoner

### 3.1 QR-kode-generering
- [ ] **3.1.1** Implementer QR-kode-generering for spesifikke steg
  - **M√•l**: Generer QR-kode basert p√• n√•v√¶rende URL
  - **üåê TEST I NETTLESER**: Verifiser at QR-kode genereres og vises korrekt
- [ ] **3.1.2** QR-kode for prosjekt (starter p√• f√∏rste steg)
  - **M√•l**: QR-kode som peker til prosjektets f√∏rste steg
  - **üåê TEST I NETTLESER**: Test at QR-kode for prosjekt peker til riktig URL
- [ ] **3.1.3** QR-kode for spesifikt steg
  - **M√•l**: QR-kode som peker til spesifikt steg med step-parameter
  - **üåê TEST I NETTLESER**: Test at QR-kode for steg peker til riktig URL med step-parameter
- [ ] **3.1.4** Deling via QR-kode
  - **M√•l**: Mulighet for √• dele spesifikke steg via QR-kode
  - **üåê TEST I NETTLESER**: Test at QR-kode kan skannes og navigerer til riktig sted

### 3.2 Ekstra funksjoner
- [ ] **3.2.1** S√∏kefunksjonalitet i prosjekter
  - **M√•l**: S√∏kefelt for √• finne prosjekter basert p√• navn
  - **üåê TEST I NETTLESER**: Test s√∏kefunksjonalitet og verifiser at riktige resultater vises
- [ ] **3.2.2** Filtrering/kategorisering av prosjekter
  - **M√•l**: Filtrer prosjekter basert p√• kategorier eller tags
  - **üåê TEST I NETTLESER**: Test filtrering og verifiser at prosjekter filtreres korrekt
- [ ] **3.2.3** Favoritter/bookmarking
  - **M√•l**: Lagre favoritt-prosjekter i localStorage
  - **üåê TEST I NETTLESER**: Test at favoritter lagres og vises korrekt
- [ ] **3.2.4** Eksport av instruksjoner (PDF?)
  - **M√•l**: Eksporter instruksjoner til PDF eller annet format
  - **üåê TEST I NETTLESER**: Test eksport-funksjonalitet hvis implementert

## Fase 4: Progressive Web App (PWA)

### 4.1 Web App Manifest
- [ ] **4.1.1** Opprett manifest.json
  - **M√•l**: Web App Manifest med app-navn, ikoner, start-URL, display-mode
  - **üåê TEST I NETTLESER**: Verifiser at manifest.json lastes korrekt
- [ ] **4.1.2** Legg til app-ikoner (flere st√∏rrelser)
  - **M√•l**: Ikoner for iOS, Android og desktop (192x192, 512x512, etc.)
  - **üåê TEST I NETTLESER**: Verifiser at ikoner vises korrekt i browser
- [ ] **4.1.3** Konfigurer manifest for installasjon
  - **M√•l**: display: "standalone", start_url, theme_color, background_color
  - **üåê TEST I NETTLESER**: Test installasjonsprompt i nettleser

### 4.2 Service Worker
- [ ] **4.2.1** Opprett service-worker.js
  - **M√•l**: Grunnleggende Service Worker med install/activate events
  - **üåê TEST I NETTLESER**: Verifiser at Service Worker registreres i Application-tab
- [ ] **4.2.2** Implementer caching-strategi for statiske ressurser
  - **M√•l**: Cache HTML, CSS, JS ved install (Cache First)
  - **üåê TEST I NETTLESER**: Test offline-tilgang til statiske filer
- [ ] **4.2.3** Implementer caching-strategi for bilder
  - **M√•l**: Cache bilder ved bruk (Cache First eller Network First med fallback)
  - **üåê TEST I NETTLESER**: Test at bilder caches og fungerer offline
- [ ] **4.2.4** Implementer caching-strategi for JSON-data
  - **M√•l**: Cache projects.json og meta.json (Network First med cache fallback)
  - **üåê TEST I NETTLESER**: Test at JSON-data fungerer offline
- [ ] **4.2.5** Implementer cache-oppdatering og versjonering
  - **M√•l**: Oppdater cache ved nye versjoner, fjern gamle caches
  - **üåê TEST I NETTLESER**: Test cache-oppdatering ved deploy

### 4.3 Offline-st√∏tte
- [ ] **4.3.1** Offline-fallback side
  - **M√•l**: Vis offline-melding hvis ressurser ikke er tilgjengelige
  - **üåê TEST I NETTLESER**: Test offline-tilstand (DevTools ‚Üí Network ‚Üí Offline)
- [ ] **4.3.2** Offline-indikator
  - **M√•l**: Vis visuell indikator n√•r appen er offline
  - **üåê TEST I NETTLESER**: Test at offline-indikator vises korrekt
- [ ] **4.3.3** Sync av progresjon n√•r online
  - **M√•l**: Sikre at progresjon synkroniseres n√•r nettverk kommer tilbake
  - **üåê TEST I NETTLESER**: Test sync ved nettverksgjenoppretting

### 4.4 Installerbar app
- [ ] **4.4.1** Installasjonsprompt
  - **M√•l**: Vis "Installer app"-prompt n√•r kriterier er oppfylt
  - **üåê TEST I NETTLESER**: Test installasjonsprompt i nettleser
- [ ] **4.4.2** App-ikon p√• hjemmeskjerm
  - **M√•l**: Verifiser at app vises korrekt n√•r installert
  - **üåê TEST I NETTLESER**: Installer app og verifiser at ikon vises
- [ ] **4.4.3** Standalone-modus
  - **M√•l**: App skal fungere i standalone-modus (uten browser UI)
  - **üåê TEST I NETTLESER**: Test app i standalone-modus etter installasjon

### 4.5 PWA-testing og optimalisering
- [ ] **4.5.1** Lighthouse PWA-audit
  - **M√•l**: Oppn√• minst 90+ score p√• Lighthouse PWA-audit
  - **üåê TEST I NETTLESER**: Kj√∏r Lighthouse audit og verifiser score
- [ ] **4.5.2** Test p√• ulike enheter
  - **M√•l**: Test PWA-funksjonalitet p√• iOS, Android og desktop
  - **üåê TEST I NETTLESER**: Test installasjon og offline-funksjonalitet p√• ulike enheter
- [ ] **4.5.3** Optimaliser cache-st√∏rrelse
  - **M√•l**: S√∏rg for at cache ikke blir for stor, implementer cache-quota-h√•ndtering
  - **üåê TEST I NETTLESER**: Verifiser cache-st√∏rrelse i Application-tab

## Milep√¶ler

### M1: MVP (Minimum Viable Product)
**Status**: NOT_STARTED

Grunnleggende funksjonalitet:
- Prosjektgalleri fungerer
- Navigasjon mellom steg fungerer
- Progresjonslinje fungerer
- localStorage-lagring fungerer
- Responsivt design p√• mobil/PC

**Kriterier for ferdig**:
- Kan vise minst ett prosjekt med flere steg
- Kan navigere mellom steg
- Progresjon lagres og gjenopptas
- Fungerer p√• mobil og PC

### M2: F√∏rste versjon (v1.0)
**Status**: NOT_STARTED

Alle funksjoner fra Fase 1 implementert og testet.

**Kriterier for ferdig**:
- Alle funksjoner fra Fase 1 er implementert
- Testet med flere prosjekter og underprosjekter
- Dokumentasjon er komplett
- Ingen kritiske bugs

### M3: Forbedret versjon (v1.1)
**Status**: NOT_STARTED

Fase 2-funksjoner implementert.

**Kriterier for ferdig**:
- Loading-indikatorer og preloading
- Tastaturnavigasjon og touch gestures
- Caching-strategier implementert
- Bedre brukeropplevelse

### M4: Avansert versjon (v2.0)
**Status**: NOT_STARTED

Fase 3-funksjoner implementert, inkludert QR-kode.

**Kriterier for ferdig**:
- QR-kode-generering fungerer
- Alle avanserte funksjoner implementert
- Fullstendig dokumentasjon

### M5: Progressive Web App (v3.0)
**Status**: NOT_STARTED

Fase 4-funksjoner implementert, full PWA-st√∏tte.

**Kriterier for ferdig**:
- Web App Manifest implementert
- Service Worker med caching-strategier fungerer
- Offline-st√∏tte fungerer
- App kan installeres p√• enheter
- Lighthouse PWA-score minst 90+
- Fungerer i standalone-modus

## Prioritering

### H√∏y prioritet (Fase 1)
Disse funksjonene er essensielle for at prosjektet skal fungere. Se [ARCHITECTURE.md](./ARCHITECTURE.md) for detaljer:
- Router og routing
- Data-loader
- View-komponenter
- localStorage-lagring
- Grunnleggende CSS

### Middels prioritet (Fase 2)
Disse forbedrer brukeropplevelsen betydelig:
- Loading-indikatorer
- Tastaturnavigasjon
- Caching og preloading
- Touch gestures

### Lav prioritet (Fase 3)
Disse er "nice to have" og kan implementeres senere:
- QR-kode-generering
- S√∏k og filtrering
- Favoritter
- Eksport-funksjoner

### Fremtidig (Fase 4)
PWA-funksjonalitet for full offline-st√∏tte og installerbar app:
- Web App Manifest
- Service Worker
- Offline-st√∏tte
- Installerbar app

## Tekniske gjeld og forbedringer

### Kjent teknisk gjeld
- Ingen offline-st√∏tte enn√• (kommer i Fase 4)
- Ingen error boundaries eller feilh√•ndtering
- Ingen loading states (kommer i Fase 2)
- Ingen Service Worker caching-strategi (kommer i Fase 4)

### Fremtidige forbedringer
- TypeScript for type-sikkerhet (hvis kompleksitet vokser)
- Testing-framework (hvis prosjektet vokser)
- Build tools (hvis behovet oppst√•r)
- Progressive Web App (PWA) - planlagt i Fase 4

## Tidsestimater

**Merk**: Tidsestimatene er for menneskelig utviklingstid, ikke for AI-kj√∏ring, men beholdes for planleggingsf√∏lelse. Disse er grove estimater og kan variere.

- **Fase 1**: 2-4 uker (avhengig av tidsbruk)
- **Fase 2**: 1-2 uker
- **Fase 3**: 2-3 uker
- **Fase 4**: 2-3 uker (PWA)

**Totalt estimat for f√∏rste versjon (v1.0)**: 2-4 uker
**Totalt estimat for PWA-versjon (v3.0)**: 7-12 uker

## Notater

- Implementer funksjoner inkrementelt og test hver del
- **üåê Viktig**: Alle steg markert med "TEST I NETTLESER" skal testes i nettleseren f√∏r man g√•r videre
- Hold koden enkel og modul√¶r
- Dokumenter endringer underveis
- Test p√• ulike enheter og nettlesere
- Vurder refaktorering hvis filer blir for store (se ARCHITECTURE.md)

## Testing i nettleseren

For alle steg markert med **üåê TEST I NETTLESER**:

1. √Öpne nettstedet i nettleseren (via lokal webserver, se README.md)
2. Test funksjonaliteten manuelt
3. Bruk DevTools for √• verifisere:
   - **Console**: Sjekk for JavaScript-feil
   - **Network**: Verifiser at filer lastes korrekt
   - **Application**: Sjekk localStorage og sessionStorage
   - **Elements**: Inspiser DOM-struktur
4. Test p√• ulike skjermst√∏rrelser (DevTools device mode)
5. Verifiser at funksjonaliteten fungerer som forventet f√∏r du g√•r videre

## Oppdateringshistorikk

- **2024-XX-XX**: Opprettet roadmap



--------------------------------------------------
File End
--------------------------------------------------
